{"version":3,"file":"726.bc9a031ea10eaed4.js","mappings":"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","names":["ObjectPainter","decodeOptions","opt","this","options","Zscale","indexOf","createRGBA","nlevels","obj","getObject","fPalette","rgba","Array","indx","pal","lvl","l","fPoints","length","r1","r2","Math","min","round","fColorRed","fColorGreen","fColorBlue","fColorAlpha","makeUrlFromImageBuf","fp","fImgBuf","max","k","v","fContour","arr","getLevels","getPaletteColor","zval","toHex","xmin","xmax","fWidth","ymin","ymax","fHeight","zoom_xmin","zoom_xmax","zoom_ymin","zoom_ymax","isNodeJs","s","then","h","default","createCanvas","Promise","resolveFunc","c","document","createElement","width","height","canvas","context","getContext","imageData","getImageData","data","i","dst","row","j","iii","putImageData","url","toDataURL","constRatio","fConstRatio","is_buf","makeUrlFromPngBuf","buf","fPngBuf","pngbuf","String","fromCharCode","resolve","btoa_func","drawImage","promise","getFramePainter","rect","getFrameRect","getPadPainter","getPadRect","wheel_zoomy","_blob","t","console","error","fImageQuality","fImageCompression","_typename","fUniqueID","fBits","fNumPoints","res","createG","append","attr","isMainPainter","drawColorPalette","setAxesRanges","create","createXY","ndim","check_pad_range","addInteractivity","canZoomInside","axis","enabled","can_move","draw_palette","Object","assign","fName","fH","fAxis","fX1NDC","fX2NDC","fY1NDC","fY2NDC","fInit","fChopt","pal_painter","findPainterFor","Enabled","removeG","frame_painter","drawPave","prev_name","selectCurrentPad","getPadName","TPavePainter","getDom","p","$secondary","redraw","toggleColz","can_toggle","reason","img","draw_g","select","empty","getFrameWidth","getFrameHeight","clickButton","funcname","fillToolbar","pp","addPadButton","showPadButtons","dom","painter","TASImagePainter","ensureTCanvas"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TASImagePainter.mjs"],"sourcesContent":["import { create, isNodeJs, btoa_func } from '../core.mjs';\nimport { toHex } from '../base/colors.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TPavePainter } from '../hist/TPavePainter.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\n\n/**\n * @summary Painter for TASImage object.\n *\n * @private\n */\n\nclass TASImagePainter extends ObjectPainter {\n\n   /** @summary Decode options string  */\n   decodeOptions(opt) {\n      this.options = { Zscale: false };\n\n      if (opt && (opt.indexOf(\"z\") >= 0)) this.options.Zscale = true;\n   }\n\n   /** @summary Create RGBA buffers */\n   createRGBA(nlevels) {\n      let obj = this.getObject();\n\n      if (!obj?.fPalette) return null;\n\n      let rgba = new Array((nlevels+1) * 4), indx = 1, pal = obj.fPalette; // precaclucated colors\n\n      for(let lvl = 0; lvl <= nlevels; ++lvl) {\n         let l = 1.*lvl/nlevels;\n         while ((pal.fPoints[indx] < l) && (indx < pal.fPoints.length-1)) indx++;\n\n         let r1 = (pal.fPoints[indx] - l) / (pal.fPoints[indx] - pal.fPoints[indx-1]),\n             r2 = (l - pal.fPoints[indx-1]) / (pal.fPoints[indx] - pal.fPoints[indx-1]);\n\n         rgba[lvl*4]   = Math.min(255, Math.round((pal.fColorRed[indx-1] * r1 + pal.fColorRed[indx] * r2) / 256));\n         rgba[lvl*4+1] = Math.min(255, Math.round((pal.fColorGreen[indx-1] * r1 + pal.fColorGreen[indx] * r2) / 256));\n         rgba[lvl*4+2] = Math.min(255, Math.round((pal.fColorBlue[indx-1] * r1 + pal.fColorBlue[indx] * r2) / 256));\n         rgba[lvl*4+3] = Math.min(255, Math.round((pal.fColorAlpha[indx-1] * r1 + pal.fColorAlpha[indx] * r2) / 256));\n      }\n\n      return rgba;\n   }\n\n   /** @summary Create url using image buffer\n     * @private */\n   makeUrlFromImageBuf(obj, fp) {\n\n      let nlevels = 1000;\n      this.rgba = this.createRGBA(nlevels); // precaclucated colors\n\n      let min = obj.fImgBuf[0], max = obj.fImgBuf[0];\n      for (let k = 1; k < obj.fImgBuf.length; ++k) {\n         let v = obj.fImgBuf[k];\n         min = Math.min(v, min);\n         max = Math.max(v, max);\n      }\n\n      // does not work properly in Node.js, causes \"Maximum call stack size exceeded\" error\n      // min = Math.min.apply(null, obj.fImgBuf),\n      // max = Math.max.apply(null, obj.fImgBuf);\n\n      // create countor like in hist painter to allow palette drawing\n      this.fContour = {\n         arr: new Array(200),\n         rgba: this.rgba,\n         getLevels() { return this.arr; },\n         getPaletteColor(pal, zval) {\n            if (!this.arr || !this.rgba) return \"white\";\n            let indx = Math.round((zval - this.arr[0]) / (this.arr[this.arr.length-1] - this.arr[0]) * (this.rgba.length-4)/4) * 4;\n            return \"#\" + toHex(this.rgba[indx],1) + toHex(this.rgba[indx+1],1) + toHex(this.rgba[indx+2],1) + toHex(this.rgba[indx+3],1);\n         }\n      };\n      for (let k = 0; k < 200; k++)\n         this.fContour.arr[k] = min + (max-min)/(200-1)*k;\n\n      if (min >= max) max = min + 1;\n\n      let xmin = 0, xmax = obj.fWidth, ymin = 0, ymax = obj.fHeight; // dimension in pixels\n\n      if (fp && (fp.zoom_xmin != fp.zoom_xmax)) {\n         xmin = Math.round(fp.zoom_xmin * obj.fWidth);\n         xmax = Math.round(fp.zoom_xmax * obj.fWidth);\n      }\n\n      if (fp && (fp.zoom_ymin != fp.zoom_ymax)) {\n         ymin = Math.round(fp.zoom_ymin * obj.fHeight);\n         ymax = Math.round(fp.zoom_ymax * obj.fHeight);\n      }\n\n      let pr = isNodeJs() ?\n                 import('canvas').then(h => h.default.createCanvas(xmax - xmin, ymax - ymin)) :\n                 new Promise(resolveFunc => {\n                    let c = document.createElement('canvas');\n                    c.width = xmax - xmin;\n                    c.height = ymax - ymin;\n                    resolveFunc(c);\n                 });\n\n      return pr.then(canvas => {\n\n         let context = canvas.getContext('2d'),\n             imageData = context.getImageData(0, 0, canvas.width, canvas.height),\n             arr = imageData.data;\n\n         for(let i = ymin; i < ymax; ++i) {\n            let dst = (ymax - i - 1) * (xmax - xmin) * 4,\n                row = i * obj.fWidth;\n            for(let j = xmin; j < xmax; ++j) {\n               let iii = Math.round((obj.fImgBuf[row + j] - min) / (max - min) * nlevels) * 4;\n               // copy rgba value for specified point\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n            }\n         }\n\n         context.putImageData(imageData, 0, 0);\n\n         return { url: canvas.toDataURL(), constRatio: obj.fConstRatio, is_buf: true };\n      });\n   }\n\n   makeUrlFromPngBuf(obj) {\n      let buf = obj.fPngBuf, pngbuf = \"\";\n\n      if (typeof buf == \"string\")\n         pngbuf = buf;\n      else\n         for (let k = 0; k < buf.length; ++k)\n            pngbuf += String.fromCharCode(buf[k] < 0 ? 256 + buf[k] : buf[k]);\n\n      return Promise.resolve({ url: \"data:image/png;base64,\" + btoa_func(pngbuf), constRatio: true });\n   }\n\n   /** @summary Draw image */\n   drawImage() {\n      let obj = this.getObject(),\n          fp = this.getFramePainter(),\n          rect = fp ? fp.getFrameRect() : this.getPadPainter().getPadRect();\n\n      this.wheel_zoomy = true;\n\n      if (obj._blob) {\n         // try to process blob data due to custom streamer\n         if ((obj._blob.length == 15) && !obj._blob[0]) {\n            obj.fImageQuality = obj._blob[1];\n            obj.fImageCompression = obj._blob[2];\n            obj.fConstRatio = obj._blob[3];\n            obj.fPalette = {\n                _typename: \"TImagePalette\",\n                fUniqueID: obj._blob[4],\n                fBits: obj._blob[5],\n                fNumPoints: obj._blob[6],\n                fPoints: obj._blob[7],\n                fColorRed: obj._blob[8],\n                fColorGreen: obj._blob[9],\n                fColorBlue: obj._blob[10],\n                fColorAlpha: obj._blob[11]\n            };\n\n            obj.fWidth = obj._blob[12];\n            obj.fHeight = obj._blob[13];\n            obj.fImgBuf = obj._blob[14];\n\n            if ((obj.fWidth * obj.fHeight != obj.fImgBuf.length) ||\n                  (obj.fPalette.fNumPoints != obj.fPalette.fPoints.length)) {\n               console.error('TASImage _blob decoding error', obj.fWidth * obj.fHeight, '!=', obj.fImgBuf.length, obj.fPalette.fNumPoints, \"!=\", obj.fPalette.fPoints.length);\n               delete obj.fImgBuf;\n               delete obj.fPalette;\n            }\n\n         } else if ((obj._blob.length == 3) && obj._blob[0]) {\n            obj.fPngBuf = obj._blob[2];\n            if (obj.fPngBuf?.length != obj._blob[1]) {\n               console.error(`TASImage with png buffer _blob error ${obj._blob[1]} != ${obj.fPngBuf?.length}`);\n               delete obj.fPngBuf;\n            }\n         } else {\n            console.error(`TASImage _blob len ${obj._blob.length} not recognized`);\n         }\n\n         delete obj._blob;\n      }\n\n      let promise;\n\n      if (obj.fImgBuf && obj.fPalette) {\n         promise = this.makeUrlFromImageBuf(obj, fp);\n      } else if (obj.fPngBuf) {\n         promise = this.makeUrlFromPngBuf(obj);\n      } else {\n         promise = Promise.resolve({});\n      }\n\n      return promise.then(res => {\n\n         if (res.url)\n            this.createG(fp ? true : false)\n                .append(\"image\")\n                .attr(\"href\", res.url)\n                .attr(\"width\", rect.width)\n                .attr(\"height\", rect.height)\n                .attr(\"preserveAspectRatio\", res.constRatio ? null : \"none\");\n\n         if (!res.url || !this.isMainPainter() || !res.is_buf || !fp)\n            return this;\n\n         return this.drawColorPalette(this.options.Zscale, true).then(() => {\n            fp.setAxesRanges(create(\"TAxis\"), 0, 1, create(\"TAxis\"), 0, 1, null, 0, 0);\n            fp.createXY({ ndim: 2, check_pad_range: false });\n            return fp.addInteractivity();\n         })\n      });\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      let obj = this.getObject();\n\n      if (!obj?.fImgBuf)\n         return false;\n\n      if ((axis == \"x\") && ((max - min) * obj.fWidth > 3)) return true;\n\n      if ((axis == \"y\") && ((max - min) * obj.fHeight > 3)) return true;\n\n      return false;\n   }\n\n   /** @summary Draw color palette\n     * @private */\n   drawColorPalette(enabled, can_move) {\n\n      if (!this.isMainPainter())\n         return Promise.resolve(null);\n\n      if (!this.draw_palette) {\n         let pal = create('TPave');\n\n         Object.assign(pal, { _typename: \"TPaletteAxis\", fName: \"TPave\", fH: null, fAxis: create('TGaxis'),\n                               fX1NDC: 0.91, fX2NDC: 0.95, fY1NDC: 0.1, fY2NDC: 0.9, fInit: 1 } );\n\n         pal.fAxis.fChopt = \"+\";\n\n         this.draw_palette = pal;\n         this.fPalette = true; // to emulate behaviour of hist painter\n      }\n\n      let pal_painter = this.getPadPainter().findPainterFor(this.draw_palette);\n\n      if (!enabled) {\n         if (pal_painter) {\n            pal_painter.Enabled = false;\n            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad\n         }\n         return Promise.resolve(null);\n      }\n\n      let frame_painter = this.getFramePainter();\n\n      // keep palette width\n      if (can_move && frame_painter) {\n         let pal = this.draw_palette;\n         pal.fX2NDC = frame_painter.fX2NDC + 0.01 + (pal.fX2NDC - pal.fX1NDC);\n         pal.fX1NDC = frame_painter.fX2NDC + 0.01;\n         pal.fY1NDC = frame_painter.fY1NDC;\n         pal.fY2NDC = frame_painter.fY2NDC;\n      }\n\n      if (pal_painter) {\n         pal_painter.Enabled = true;\n         return pal_painter.drawPave(\"\");\n      }\n\n\n      let prev_name = this.selectCurrentPad(this.getPadName());\n\n      return TPavePainter.draw(this.getDom(), this.draw_palette).then(p => {\n\n         pal_painter = p;\n\n         this.selectCurrentPad(prev_name);\n         // mark painter as secondary - not in list of TCanvas primitives\n         pal_painter.$secondary = true;\n\n         // make dummy redraw, palette will be updated only from histogram painter\n         pal_painter.redraw = function() {};\n      });\n   }\n\n   /** @summary Toggle colz draw option\n     * @private */\n   toggleColz() {\n      let obj = this.getObject(),\n          can_toggle = obj && obj.fPalette;\n\n      if (can_toggle) {\n         this.options.Zscale = !this.options.Zscale;\n         this.drawColorPalette(this.options.Zscale, true);\n      }\n   }\n\n   /** @summary Redraw image */\n   redraw(reason) {\n      let img = this.draw_g ? this.draw_g.select(\"image\") : null,\n          fp = this.getFramePainter();\n\n      if (img && !img.empty() && (reason !== \"zoom\") && fp) {\n         img.attr(\"width\", fp.getFrameWidth()).attr(\"height\", fp.getFrameHeight());\n      } else {\n         return this.drawImage();\n      }\n   }\n\n   /** @summary Process click on TASImage-defined buttons */\n   clickButton(funcname) {\n      if (!this.isMainPainter()) return false;\n\n      switch(funcname) {\n         case \"ToggleColorZ\": this.toggleColz(); break;\n         default: return false;\n      }\n\n      return true;\n   }\n\n   /** @summary Fill pad toolbar for TASImage */\n   fillToolbar() {\n      let pp = this.getPadPainter(), obj = this.getObject();\n      if (pp && obj?.fPalette) {\n         pp.addPadButton(\"th2colorz\", \"Toggle color palette\", \"ToggleColorZ\");\n         pp.showPadButtons();\n      }\n   }\n\n   /** @summary Draw TASImage object */\n   static draw(dom, obj, opt) {\n      let painter = new TASImagePainter(dom, obj, opt);\n      painter.decodeOptions(opt);\n      return ensureTCanvas(painter, false)\n                 .then(() => painter.drawImage())\n                 .then(() => {\n                     painter.fillToolbar();\n                     return painter;\n                 });\n   }\n\n} // class TASImagePainter\n\nexport { TASImagePainter };\n"]}