{"version":3,"file":"728.67f53582cf0b76c3.js","mappings":"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","names":["ObjectPainter","constructor","dom","polargram","super","this","$polargram","zoom_rmin","zoom_rmax","translate","angle","radius","keep_float","_rx","r","_ry","szx","szy","pos","x","Math","cos","y","sin","rx","ry","round","format","toString","ndig","toExponential","toFixed","axisAsText","axis","value","PI","getFrameRect","pp","getPadPainter","pad","getRootPad","w","getPadWidth","h","getPadHeight","rect","max","fLeftMargin","fRightMargin","fBottomMargin","fTopMargin","width","height","hint_delta_x","hint_delta_y","transform","mouseEvent","kind","evnt","interactive","getLayerSvg","select","empty","pnt","d3_pointer","node","touch","processFrameTooltipEvent","mouseWheel","stopPropagation","preventDefault","polar","getObject","delta","wheelDelta","deltaY","detail","rmin","scale_rmin","rmax","scale_rmax","fRwrmin","fRwrmax","redrawPad","redraw","isMainPainter","createG","draw_g","attr","scaleLinear","domain","range","fAxisAngle","ticks","nminor","floor","fNdivRad","createAttLine","gridatt","TAttLineHandler","color","fLineColor","style","abs","log10","length","lbls","indx","lbl","indexOf","push","exclude_last","startTextDrawing","fRadialLabelFont","fRadialTextSize","n","append","call","lineatt","func","drawText","align","text","getColor","fRadialLabelColor","latex","dr","nn","gridr","nmajor","fNdivPol","finishTextDrawing","then","fontsize","fPolarTextSize","fPolarLabelFont","aligns","aindx","fPolarLabelColor","isBatchMode","TooltipHandler","layer","classed","on","d3_select","parentNode","settings","main","getElementMainPainter","Error","painter","TGraphPolargramPainter","ensureTCanvas","setAsMainPainter","drawGraphPolar","decodeOptions","opt","d","DrawOptions","options","Object","assign","mark","check","err","fill","line","curve","storeDrawOpt","graph","getMainPainter","createAttMarker","createAttFill","mpath","epath","lpath","bins","fNpoints","fY","pos1","fX","fEY","pos2","fEX","markeratt","create","grx","gry","fillatt","buildSvgPath","path","createPolargram","gr","min","extractTooltip","best_dist2","bestindx","bestpos","dist2","match_distance","used","getFullSize","sqrt","res","name","fName","title","fTitle","color1","exact","lines","getObjectHint","binindx","menu_dist","showTooltip","hint","ttcircle","changed","property","remove","processTooltipEvent","disabled","TGraphPolarPainter","console","error","pr","Promise","resolve","fPolargram","draw","addToPadPrimitives"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TGraphPolarPainter.mjs"],"sourcesContent":["import { settings, create, isBatchMode } from '../core.mjs';\nimport { scaleLinear, select as d3_select, pointer as d3_pointer } from '../d3.mjs';\nimport { DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter, getElementMainPainter } from '../base/ObjectPainter.mjs';\nimport { TAttLineHandler } from '../base/TAttLineHandler.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\nimport { TooltipHandler } from '../gpad/TFramePainter.mjs';\n\n\n/**\n * @summary Painter for TGraphPolargram objects.\n *\n * @private */\n\nclass TGraphPolargramPainter extends ObjectPainter {\n\n   /** @summary Create painter\n     * @param {object|string} dom - DOM element for drawing or element id\n     * @param {object} polargram - object to draw */\n   constructor(dom, polargram) {\n      super(dom, polargram);\n      this.$polargram = true; // indicate that this is polargram\n      this.zoom_rmin = this.zoom_rmax = 0;\n   }\n\n   /** @summary Translate coordinates */\n   translate(angle, radius, keep_float) {\n      let _rx = this.r(radius), _ry = _rx/this.szx*this.szy,\n          pos = {\n            x: _rx * Math.cos(-angle - this.angle),\n            y: _ry * Math.sin(-angle - this.angle),\n            rx: _rx,\n            ry: _ry\n         };\n\n      if (!keep_float) {\n         pos.x = Math.round(pos.x);\n         pos.y = Math.round(pos.y);\n         pos.rx =  Math.round(pos.rx);\n         pos.ry =  Math.round(pos.ry);\n      }\n      return pos;\n   }\n\n   /** @summary format label for radius ticks */\n   format(radius) {\n\n      if (radius === Math.round(radius)) return radius.toString();\n      if (this.ndig>10) return radius.toExponential(4);\n\n      return radius.toFixed((this.ndig > 0) ? this.ndig : 0);\n   }\n\n   /** @summary Convert axis values to text */\n   axisAsText(axis, value) {\n\n      if (axis == \"r\") {\n         if (value === Math.round(value)) return value.toString();\n         if (this.ndig>10) return value.toExponential(4);\n         return value.toFixed(this.ndig+2);\n      }\n\n      value *= 180/Math.PI;\n      return (value === Math.round(value)) ? value.toString() : value.toFixed(1);\n   }\n\n   /** @summary Returns coordinate of frame - without using frame itself */\n   getFrameRect() {\n      let pp = this.getPadPainter(),\n          pad = pp.getRootPad(true),\n          w = pp.getPadWidth(),\n          h = pp.getPadHeight(),\n          rect = {};\n\n      if (pad) {\n         rect.szx = Math.round(Math.max(0.1, 0.5 - Math.max(pad.fLeftMargin, pad.fRightMargin))*w);\n         rect.szy = Math.round(Math.max(0.1, 0.5 - Math.max(pad.fBottomMargin, pad.fTopMargin))*h);\n      } else {\n         rect.szx = Math.round(0.5*w);\n         rect.szy = Math.round(0.5*h);\n      }\n\n      rect.width = 2*rect.szx;\n      rect.height = 2*rect.szy;\n      rect.x = Math.round(w/2 - rect.szx);\n      rect.y = Math.round(h/2 - rect.szy);\n\n      rect.hint_delta_x = rect.szx;\n      rect.hint_delta_y = rect.szy;\n\n      rect.transform = `translate(${rect.x},${rect.y})`;\n\n      return rect;\n   }\n\n   /** @summary Process mouse event */\n   mouseEvent(kind, evnt) {\n      let layer = this.getLayerSvg(\"primitives_layer\"),\n          interactive = layer.select(\".interactive_ellipse\");\n      if (interactive.empty()) return;\n\n      let pnt = null;\n\n      if (kind !== 'leave') {\n         let pos = d3_pointer(evnt, interactive.node());\n         pnt = { x: pos[0], y: pos[1], touch: false };\n      }\n\n      this.processFrameTooltipEvent(pnt);\n   }\n\n   /** @summary Process mouse wheel event */\n   mouseWheel(evnt) {\n      evnt.stopPropagation();\n      evnt.preventDefault();\n\n      this.processFrameTooltipEvent(null); // remove all tooltips\n\n      let polar = this.getObject();\n\n      if (!polar) return;\n\n      let delta = evnt.wheelDelta ? -evnt.wheelDelta : (evnt.deltaY || evnt.detail);\n      if (!delta) return;\n\n      delta = (delta<0) ? -0.2 : 0.2;\n\n      let rmin = this.scale_rmin, rmax = this.scale_rmax, range = rmax - rmin;\n\n      // rmin -= delta*range;\n      rmax += delta*range;\n\n      if ((rmin<polar.fRwrmin) || (rmax>polar.fRwrmax)) rmin = rmax = 0;\n\n      if ((this.zoom_rmin != rmin) || (this.zoom_rmax != rmax)) {\n         this.zoom_rmin = rmin;\n         this.zoom_rmax = rmax;\n         this.redrawPad();\n      }\n   }\n\n   /** @summary Redraw polargram */\n   redraw() {\n      if (!this.isMainPainter()) return;\n\n      let polar = this.getObject(),\n          rect = this.getPadPainter().getFrameRect();\n\n      this.createG();\n\n      this.draw_g.attr(\"transform\", `translate(${Math.round(rect.x + rect.width/2)},${Math.round(rect.y + rect.height/2)})`);\n      this.szx = rect.szx;\n      this.szy = rect.szy;\n\n      this.scale_rmin = polar.fRwrmin;\n      this.scale_rmax = polar.fRwrmax;\n      if (this.zoom_rmin != this.zoom_rmax) {\n         this.scale_rmin = this.zoom_rmin;\n         this.scale_rmax = this.zoom_rmax;\n      }\n\n      this.r = scaleLinear().domain([this.scale_rmin, this.scale_rmax]).range([ 0, this.szx ]);\n      this.angle = polar.fAxisAngle || 0;\n\n      let ticks = this.r.ticks(5),\n          nminor = Math.floor((polar.fNdivRad % 10000) / 100);\n\n      this.createAttLine({ attr: polar });\n      if (!this.gridatt) this.gridatt = new TAttLineHandler({ color: polar.fLineColor, style: 2, width: 1 });\n\n      let range = Math.abs(polar.fRwrmax - polar.fRwrmin);\n      this.ndig = (range <= 0) ? -3 : Math.round(Math.log10(ticks.length / range));\n\n      // verify that all radius labels are unique\n      let lbls = [], indx = 0;\n      while (indx<ticks.length) {\n         let lbl = this.format(ticks[indx]);\n         if (lbls.indexOf(lbl)>=0) {\n            if (++this.ndig>10) break;\n            lbls = []; indx = 0; continue;\n          }\n         lbls.push(lbl);\n         indx++;\n      }\n\n      let exclude_last = false;\n\n      if ((ticks[ticks.length-1] < polar.fRwrmax) && (this.zoom_rmin == this.zoom_rmax)) {\n         ticks.push(polar.fRwrmax);\n         exclude_last = true;\n      }\n\n      this.startTextDrawing(polar.fRadialLabelFont, Math.round(polar.fRadialTextSize * this.szy * 2));\n\n      for (let n = 0; n < ticks.length; ++n) {\n         let rx = this.r(ticks[n]), ry = rx/this.szx*this.szy;\n         this.draw_g.append(\"ellipse\")\n             .attr(\"cx\",0)\n             .attr(\"cy\",0)\n             .attr(\"rx\",Math.round(rx))\n             .attr(\"ry\",Math.round(ry))\n             .style(\"fill\", \"none\")\n             .call(this.lineatt.func);\n\n         if ((n < ticks.length-1) || !exclude_last)\n            this.drawText({ align: 23, x: Math.round(rx), y: Math.round(polar.fRadialTextSize * this.szy * 0.5),\n                            text: this.format(ticks[n]), color: this.getColor(polar.fRadialLabelColor), latex: 0 });\n\n         if ((nminor>1) && ((n < ticks.length-1) || !exclude_last)) {\n            let dr = (ticks[1] - ticks[0]) / nminor;\n            for (let nn = 1; nn < nminor; ++nn) {\n               let gridr = ticks[n] + dr*nn;\n               if (gridr > this.scale_rmax) break;\n               rx = this.r(gridr); ry = rx/this.szx*this.szy;\n               this.draw_g.append(\"ellipse\")\n                   .attr(\"cx\",0)\n                   .attr(\"cy\",0)\n                   .attr(\"rx\",Math.round(rx))\n                   .attr(\"ry\",Math.round(ry))\n                   .style(\"fill\", \"none\")\n                   .call(this.gridatt.func);\n            }\n         }\n      }\n\n      let nmajor = polar.fNdivPol % 100;\n      if ((nmajor !== 8) && (nmajor !== 3)) nmajor = 8;\n\n      return this.finishTextDrawing().then(() => {\n\n         let fontsize = Math.round(polar.fPolarTextSize * this.szy * 2);\n         this.startTextDrawing(polar.fPolarLabelFont, fontsize);\n\n         lbls = (nmajor==8) ? [\"0\", \"#frac{#pi}{4}\", \"#frac{#pi}{2}\", \"#frac{3#pi}{4}\", \"#pi\", \"#frac{5#pi}{4}\", \"#frac{3#pi}{2}\", \"#frac{7#pi}{4}\"] : [\"0\", \"#frac{2#pi}{3}\", \"#frac{4#pi}{3}\"];\n         let aligns = [12, 11, 21, 31, 32, 33, 23, 13];\n\n         for (let n = 0; n < nmajor; ++n) {\n            let angle = -n*2*Math.PI/nmajor - this.angle;\n            this.draw_g.append(\"svg:path\")\n                .attr(\"d\",`M0,0L${Math.round(this.szx*Math.cos(angle))},${Math.round(this.szy*Math.sin(angle))}`)\n                .call(this.lineatt.func);\n\n            let aindx = Math.round(16 -angle/Math.PI*4) % 8; // index in align table, here absolute angle is important\n\n            this.drawText({ align: aligns[aindx],\n                            x: Math.round((this.szx+fontsize)*Math.cos(angle)),\n                            y: Math.round((this.szy + fontsize/this.szx*this.szy)*(Math.sin(angle))),\n                            text: lbls[n],\n                            color: this.getColor(polar.fPolarLabelColor), latex: 1 });\n         }\n\n         return this.finishTextDrawing();\n      }).then(() => {\n\n         nminor = Math.floor((polar.fNdivPol % 10000) / 100);\n\n         if (nminor > 1)\n            for (let n = 0; n < nmajor*nminor; ++n) {\n               if (n % nminor === 0) continue;\n               let angle = -n*2*Math.PI/nmajor/nminor - this.angle;\n               this.draw_g.append(\"svg:path\")\n                   .attr(\"d\",`M0,0L${Math.round(this.szx*Math.cos(angle))},${Math.round(this.szy*Math.sin(angle))}`)\n                   .call(this.gridatt.func);\n            }\n\n         if (isBatchMode()) return;\n\n         TooltipHandler.assign(this);\n\n         let layer = this.getLayerSvg(\"primitives_layer\"),\n             interactive = layer.select(\".interactive_ellipse\");\n\n         if (interactive.empty())\n            interactive = layer.append(\"g\")\n                               .classed(\"most_upper_primitives\", true)\n                               .append(\"ellipse\")\n                               .classed(\"interactive_ellipse\", true)\n                               .attr(\"cx\",0)\n                               .attr(\"cy\",0)\n                               .style(\"fill\", \"none\")\n                               .style(\"pointer-events\",\"visibleFill\")\n                               .on('mouseenter', evnt => this.mouseEvent('enter', evnt))\n                               .on('mousemove', evnt => this.mouseEvent('move', evnt))\n                               .on('mouseleave', evnt => this.mouseEvent('leave', evnt));\n\n         interactive.attr(\"rx\", this.szx).attr(\"ry\", this.szy);\n\n         d3_select(interactive.node().parentNode).attr(\"transform\", this.draw_g.attr(\"transform\"));\n\n         if (settings.Zooming && settings.ZoomWheel)\n            interactive.on(\"wheel\", evnt => this.mouseWheel(evnt));\n      });\n   }\n\n   /** @summary Draw TGraphPolargram */\n   static draw(dom, polargram /*, opt*/) {\n\n      let main = getElementMainPainter(dom);\n      if (main) {\n         if (main.getObject() === polargram)\n            return main;\n         throw Error(\"Cannot superimpose TGraphPolargram with any other drawings\");\n      }\n\n      let painter = new TGraphPolargramPainter(dom, polargram);\n      return ensureTCanvas(painter, false).then(() => {\n         painter.setAsMainPainter();\n         return painter.redraw();\n      }).then(() => painter);\n   }\n\n} // class TGraphPolargramPainter\n\n\n/**\n * @summary Painter for TGraphPolar objects.\n *\n * @private\n */\n\nclass TGraphPolarPainter extends ObjectPainter {\n\n   /** @summary Redraw TGraphPolar */\n   redraw() {\n      this.drawGraphPolar();\n   }\n\n   /** @summary Decode options for drawing TGraphPolar */\n   decodeOptions(opt) {\n\n      let d = new DrawOptions(opt || \"L\");\n\n      if (!this.options) this.options = {};\n\n      Object.assign(this.options, {\n          mark: d.check(\"P\"),\n          err: d.check(\"E\"),\n          fill: d.check(\"F\"),\n          line: d.check(\"L\"),\n          curve: d.check(\"C\")\n      });\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Drawing TGraphPolar */\n   drawGraphPolar() {\n      let graph = this.getObject(),\n          main = this.getMainPainter();\n\n      if (!graph || !main?.$polargram) return;\n\n      if (this.options.mark) this.createAttMarker({ attr: graph });\n      if (this.options.err || this.options.line || this.options.curve) this.createAttLine({ attr: graph });\n      if (this.options.fill) this.createAttFill({ attr: graph });\n\n      this.createG();\n\n      this.draw_g.attr(\"transform\", main.draw_g.attr(\"transform\"));\n\n      let mpath = \"\", epath = \"\", lpath = \"\", bins = [];\n\n      for (let n = 0; n < graph.fNpoints; ++n) {\n\n         if (graph.fY[n] > main.scale_rmax) continue;\n\n         if (this.options.err) {\n            let pos1 = main.translate(graph.fX[n], graph.fY[n] - graph.fEY[n]),\n                pos2 = main.translate(graph.fX[n], graph.fY[n] + graph.fEY[n]);\n            epath += `M${pos1.x},${pos1.y}L${pos2.x},${pos2.y}`;\n\n            pos1 = main.translate(graph.fX[n] + graph.fEX[n], graph.fY[n]);\n            pos2 = main.translate(graph.fX[n] - graph.fEX[n], graph.fY[n]);\n\n            epath += `M${pos1.x},${pos1.y}A${pos2.rx},${pos2.ry},0,0,1,${pos2.x},${pos2.y}`;\n         }\n\n         let pos = main.translate(graph.fX[n], graph.fY[n]);\n\n         if (this.options.mark) {\n            mpath += this.markeratt.create(pos.x, pos.y);\n         }\n\n         if (this.options.line || this.options.fill) {\n            lpath += (lpath ? \"L\" : \"M\") + pos.x + \",\" + pos.y;\n         }\n\n         if (this.options.curve) {\n            pos.grx = pos.x;\n            pos.gry = pos.y;\n            bins.push(pos);\n         }\n      }\n\n      if (this.options.fill && lpath)\n         this.draw_g.append(\"svg:path\")\n             .attr(\"d\", lpath + \"Z\")\n             .call(this.fillatt.func);\n\n      if (this.options.line && lpath)\n         this.draw_g.append(\"svg:path\")\n             .attr(\"d\", lpath)\n             .style(\"fill\", \"none\")\n             .call(this.lineatt.func);\n\n      if (this.options.curve && bins.length)\n         this.draw_g.append(\"svg:path\")\n                 .attr(\"d\", buildSvgPath(\"bezier\", bins).path)\n                 .style(\"fill\", \"none\")\n                 .call(this.lineatt.func);\n\n      if (epath)\n         this.draw_g.append(\"svg:path\")\n             .attr(\"d\", epath)\n             .style(\"fill\",\"none\")\n             .call(this.lineatt.func);\n\n      if (mpath)\n         this.draw_g.append(\"svg:path\")\n               .attr(\"d\", mpath)\n               .call(this.markeratt.func);\n   }\n\n   /** @summary Create polargram object */\n   createPolargram() {\n      let polargram = create(\"TGraphPolargram\"),\n          gr = this.getObject();\n\n      let rmin = gr.fY[0] || 0, rmax = rmin;\n      for (let n = 0; n < gr.fNpoints; ++n) {\n         rmin = Math.min(rmin, gr.fY[n] - gr.fEY[n]);\n         rmax = Math.max(rmax, gr.fY[n] + gr.fEY[n]);\n      }\n\n      polargram.fRwrmin = rmin - (rmax-rmin)*0.1;\n      polargram.fRwrmax = rmax + (rmax-rmin)*0.1;\n\n      return polargram;\n   }\n\n   /** @summary Provide tooltip at specified point */\n   extractTooltip(pnt) {\n      if (!pnt) return null;\n\n      let graph = this.getObject(),\n          main = this.getMainPainter(),\n          best_dist2 = 1e10, bestindx = -1, bestpos = null;\n\n      for (let n = 0; n < graph.fNpoints; ++n) {\n         let pos = main.translate(graph.fX[n], graph.fY[n]),\n             dist2 = (pos.x-pnt.x)**2 + (pos.y-pnt.y)**2;\n         if (dist2 < best_dist2) { best_dist2 = dist2; bestindx = n; bestpos = pos; }\n      }\n\n      let match_distance = 5;\n      if (this.markeratt && this.markeratt.used) match_distance = this.markeratt.getFullSize();\n\n      if (Math.sqrt(best_dist2) > match_distance) return null;\n\n      let res = { name: this.getObject().fName, title: this.getObject().fTitle,\n                  x: bestpos.x, y: bestpos.y,\n                  color1: this.markeratt && this.markeratt.used ? this.markeratt.color : this.lineatt.color,\n                  exact: Math.sqrt(best_dist2) < 4,\n                  lines: [ this.getObjectHint() ],\n                  binindx: bestindx,\n                  menu_dist: match_distance,\n                  radius: match_distance\n                };\n\n      res.lines.push(\"r = \" + main.axisAsText(\"r\", graph.fY[bestindx]));\n      res.lines.push(\"phi = \" + main.axisAsText(\"phi\",graph.fX[bestindx]));\n\n      if (graph.fEY && graph.fEY[bestindx])\n         res.lines.push(\"error r = \" + main.axisAsText(\"r\", graph.fEY[bestindx]));\n\n      if (graph.fEX && graph.fEX[bestindx])\n         res.lines.push(\"error phi = \" + main.axisAsText(\"phi\", graph.fEX[bestindx]));\n\n      return res;\n   }\n\n   /** @summary Show tooltip */\n   showTooltip(hint) {\n\n      if (!this.draw_g) return;\n\n      let ttcircle = this.draw_g.select(\".tooltip_bin\");\n\n      if (!hint) {\n         ttcircle.remove();\n         return;\n      }\n\n      if (ttcircle.empty())\n         ttcircle = this.draw_g.append(\"svg:ellipse\")\n                             .attr(\"class\",\"tooltip_bin\")\n                             .style(\"pointer-events\",\"none\");\n\n      hint.changed = ttcircle.property(\"current_bin\") !== hint.binindx;\n\n      if (hint.changed)\n         ttcircle.attr(\"cx\", hint.x)\n               .attr(\"cy\", hint.y)\n               .attr(\"rx\", Math.round(hint.radius))\n               .attr(\"ry\", Math.round(hint.radius))\n               .style(\"fill\", \"none\")\n               .style(\"stroke\", hint.color1)\n               .property(\"current_bin\", hint.binindx);\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      let hint = this.extractTooltip(pnt);\n      if (!pnt || !pnt.disabled) this.showTooltip(hint);\n      return hint;\n   }\n\n   /** @summary Draw TGraphPolar */\n   static draw(dom, graph, opt) {\n      let painter = new TGraphPolarPainter(dom, graph);\n      painter.decodeOptions(opt);\n\n      let main = painter.getMainPainter();\n      if (main && !main.$polargram) {\n         console.error('Cannot superimpose TGraphPolar with plain histograms');\n         return null;\n      }\n\n      let pr = Promise.resolve(null);\n      if (!main) {\n         if (!graph.fPolargram)\n            graph.fPolargram = painter.createPolargram();\n         pr = TGraphPolargramPainter.draw(dom, graph.fPolargram);\n      }\n\n      return pr.then(() => {\n         painter.addToPadPrimitives();\n         painter.drawGraphPolar();\n         return painter;\n      });\n   }\n\n} // class TGraphPolarPainter\n\nexport { TGraphPolargramPainter, TGraphPolarPainter };\n"]}