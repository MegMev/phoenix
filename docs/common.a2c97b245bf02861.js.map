{"version":3,"file":"common.a2c97b245bf02861.js","mappings":"oXAYA,aACG,IAAIA,EAAOC,KAAKC,YACZC,EAAKF,KAAKG,gBACVC,EAAIF,EAAGG,cACPC,EAAIJ,EAAGK,eACPC,EAAQT,EAAKU,GAAIC,EAAQX,EAAKY,GAC9BC,EAASZ,KAAKa,SAASd,EAAKe,YAC5BC,GAAY,EACZC,EAAO,EAAIC,EAAWlB,EAAKmB,WAAa,IACxCC,EAAOnB,KAAKoB,kBAEZrB,EAAKsB,SAAQC,SAAI,KAElBtB,KAAKuB,OAAQ,EACTC,IAAaL,EAAKM,QAEtBrB,EAAIe,EAAKO,gBACTpB,EAAIa,EAAKQ,iBACTZ,EAAY,eACJb,EAAG0B,YAAW,KAItB5B,KAAKuB,OAAQ,EACbf,EAAQE,EAAQ,GAChBX,EAAK8B,WAAa,GACbjB,IAAQA,EAAS,UAGzBZ,KAAK8B,QAAQf,GAEbf,KAAK+B,OAAOC,KAAK,YAAa,MAE9BhC,KAAKQ,MAAQR,KAAKiC,UAAU,IAAKzB,EAAOR,KAAKuB,OAC7CvB,KAAKU,MAAQV,KAAKiC,UAAU,IAAKvB,EAAOV,KAAKuB,OAE7C,IAAIW,EAAM,CAAEC,MAAOpC,EAAK8B,WAAYO,EAAGpC,KAAKQ,MAAO6B,EAAGrC,KAAKU,MAAOX,KAAMA,EAAKuC,OAAQC,MAAO3B,EAAQ4B,MAAO,GAE3G,OAAIzC,EAAK0C,aAAYP,EAAIQ,QAAU3C,EAAK0C,YAElB,UAAtBE,EAASC,WAAyBV,EAAIM,MAAQ,EAAGxB,EAAO,IAClC,aAAlBjB,EAAK6C,YAA4BV,EAAIM,MAAQ,EAAGxB,EAAO,IAE3DhB,KAAK6C,iBAAiB9C,EAAK+C,UAAWC,KAAKC,MAAO/B,EAAS,EAAKA,EAAWA,EAAS8B,KAAKE,IAAI7C,EAAEE,GAAGU,IAElGhB,KAAKkD,SAAShB,GAEPlC,KAAKmD,oBAAoBC,KAAK,MAC9BC,qBAEJrD,KAAKsD,OAAStD,KAAKuD,OAAS,EAEvBvD,KAAKwD,WACPxD,KAAKwD,SAAW,SAASC,EAAGC,GACzB1D,KAAKsD,QAAUG,EACfzD,KAAKuD,QAAUG,EACf1D,KAAK+B,OAAOC,KAAK,YAAc,aAAYhC,KAAKsD,UAAUtD,KAAKuD,aAGhEvD,KAAK2D,UACP3D,KAAK2D,QAAU,SAASC,GACrB,GAAIA,EAAa,OACjB,IAAI7D,EAAOC,KAAKC,YAChBF,EAAKU,GAAKT,KAAK6D,UAAU,IAAK7D,KAAKQ,MAAQR,KAAKsD,OAAQtD,KAAKuB,OAC7DxB,EAAKY,GAAKX,KAAK6D,UAAU,IAAK7D,KAAKU,MAAQV,KAAKuD,OAAQvD,KAAKuB,OAC7DvB,KAAK8D,eAAgB,QAAO/D,EAAKU,aAAaV,EAAKY,YAGzDoD,OAAe/D,OApBWA,OA4BhC,WAAmBgE,EAAKC,GAErB,IAAIC,EAAU,IAAIC,KAAcH,EAAKC,GAErCC,SAAQE,OAAS,WACd,MAAMC,GAAW/C,SAAI,IACfgD,EAAOtE,KAAKC,YACZsE,EAAU,IAAIC,KAAgBF,GAC9B/C,EAAQ+C,EAAKjD,QAAQgD,GAG3B,YAAKvC,UAEL9B,KAAK+B,OACA0C,OAAO,YACPzC,KAAK,IAAM,IAAGhC,KAAKiC,UAAU,IAAKqC,EAAKI,IAAKnD,MAAUvB,KAAKiC,UAAU,IAAKqC,EAAKK,IAAKpD,MAAUvB,KAAKiC,UAAU,IAAKqC,EAAKM,IAAKrD,MAAUvB,KAAKiC,UAAU,IAAKqC,EAAKO,IAAKtD,MACpKuD,KAAKP,EAAQQ,MAEX/E,OAGHgF,mBAAcd,GAAS,GAAOd,KAAK,IAAMc,EAAQE,UAK3D,aAGGpE,KAAK8B,UAEL,IAAImD,EAAWjF,KAAKC,YAChBsE,EAAU,IAAIC,KAAgBS,GAC9BC,EAAUlF,KAAKmF,cAAcF,GAC7BG,GAAe9D,SAAI,IACnBC,EAAQ0D,EAAS5D,QAAQ+D,GACzBC,EAAM,GAAIN,EAAO/E,KAAKsF,iBAAiB/D,GAE3C,QAASgE,EAAI,EAAGA,GAAKN,EAASO,aAAcD,EACzCF,IAASE,EAAI,EAAK,IAAM,KAAOR,EAAK3C,EAAE6C,EAASxE,GAAG8E,IAAM,IAAMR,EAAK1C,EAAE4C,EAAStE,GAAG4E,IAE1D,aAAtBN,EAASrC,WAA0BsC,EAAQO,cAAc,QAExDP,EAAQQ,UAASL,GAAK,KAE3BrF,KAAK+B,OACA0C,OAAO,YACPzC,KAAK,IAAKqD,GACVP,KAAKP,EAAQQ,MACbD,KAAKI,EAAQH,MAKrB,aAEG,IAAIY,EAAU3F,KAAKC,YAEnBD,KAAK4F,cAAc,CAAE5D,KAAM2D,IAC3B3F,KAAKmF,cAAc,CAAEnD,KAAM2D,IAG3B3F,KAAK8B,UAEL,IAAI+D,EAAQ7F,KAAKsF,mBACblD,EAAIyD,EAAMzD,EAAEuD,EAAQjB,KACpBrC,EAAIwD,EAAMxD,EAAEsD,EAAQhB,KACpBmB,EAAKD,EAAMzD,EAAEuD,EAAQjB,IAAMiB,EAAQI,KAAO3D,EAC1C4D,EAAK3D,EAAIwD,EAAMxD,EAAEsD,EAAQhB,IAAMgB,EAAQM,KACvCC,EAAO,GAAIC,EAAqC,GAAnBR,EAAQS,SAAqC,KAAnBT,EAAQU,QAMnE,GAH0B,UAArBV,EAAQ/C,WAA2B+C,EAAQI,KAAO,IACpDD,EAAKD,EAAMzD,EAAEuD,EAAQjB,IAAMiB,EAAQM,KAAO7D,GAEnB,UAArBuD,EAAQ/C,WAA2B+C,EAAQI,IAAM,EAAI,CACvD,IAAIO,EAAMR,EAAIS,EAAMP,EAChBQ,EAAMnE,EAAIwD,EAAMxD,EAAEsD,EAAQhB,IAAMgB,EAAQI,KACxCU,EAAMZ,EAAMzD,EAAEuD,EAAQjB,IAAMiB,EAAQM,KAAO7D,EAE/C,GAAI+D,EACDD,EAAQ,KAAII,OAASA,KAAOE,WAAaF,OAASA,KAAOE,YAAcF,QAC3DG,OAASA,KAAOF,WAAaE,OAASA,KAAOF,YAAcE,UACnE,CACJ,IAAIC,EAAaf,EAAQU,QAAQV,EAAQS,SAAS,IAAO,EAAI,EACzDO,EAAKhB,EAAQS,QAAQrD,KAAK6D,GAAG,IAAKC,EAAKlB,EAAQU,QAAQtD,KAAK6D,GAAG,IAC/DE,EAAM/D,KAAKC,MAAMsD,EAAIvD,KAAKgE,IAAIJ,IAAMK,EAAMjE,KAAKC,MAAMwD,EAAIzD,KAAKkE,IAAIN,IAKtET,EAAQ,IAJEnD,KAAKC,MAAMsD,EAAIvD,KAAKgE,IAAIF,OAAY9D,KAAKC,MAAMwD,EAAIzD,KAAKkE,IAAIJ,OAI7CP,KAAOE,OAASE,OAAeI,KAAOE,KAHrDjE,KAAKC,MAAMyD,EAAI1D,KAAKgE,IAAIJ,OAAY5D,KAAKC,MAAMuD,EAAIxD,KAAKkE,IAAIN,OAI7CF,KAAOF,OAASG,OAH/B3D,KAAKC,MAAMyD,EAAI1D,KAAKgE,IAAIF,OAAY9D,KAAKC,MAAMuD,EAAIxD,KAAKkE,IAAIJ,aAGPK,GAExC,GAAlBvB,EAAQwB,OAEbjB,EADCC,EACO,KAAIL,OAAQA,KAAME,WAAYF,OAAQA,KAAME,YAAaF,OAMzD,QAJC/C,KAAKC,MAAM8C,EAAK/C,KAAKgE,IAAIpB,EAAQS,QAAQrD,KAAK6D,GAAG,SACjD7D,KAAKC,MAAMgD,EAAKjD,KAAKkE,IAAItB,EAAQS,QAAQrD,KAAK6D,GAAG,SAG/Bd,KAAME,WAFxBjD,KAAKC,MAAM8C,EAAK/C,KAAKgE,IAAIpB,EAAQU,QAAQtD,KAAK6D,GAAG,SACjD7D,KAAKC,MAAMgD,EAAKjD,KAAKkE,IAAItB,EAAQU,QAAQtD,KAAK6D,GAAG,aAGzD,CACL,IAAIQ,EAAKrE,KAAKgE,IAAIpB,EAAQwB,OAAOpE,KAAK6D,GAAG,KACrCS,EAAKtE,KAAKkE,IAAItB,EAAQwB,OAAOpE,KAAK6D,GAAG,KACrCU,EAAO3B,EAAQS,QAAQrD,KAAK6D,GAAG,IAE/BW,EAAK,IACLC,GAFO7B,EAAQU,QAAQtD,KAAK6D,GAAG,IAElBU,IAASC,GAAMpB,EAAiB,EAAI,IACjDsB,EAAQ,EAAGC,EAAQ,EAClBvB,IAAgBD,EAAO,QAC5B,QAASX,EAAI,EAAGA,EAAIgC,IAAMhC,EAAG,CACzB,IAAIoC,EAAQL,EAAO/B,EAAEiC,EACjB/D,EAAKkC,EAAQI,IAAMhD,KAAKgE,IAAIY,GAC5BjE,EAAKiC,EAAQM,IAAMlD,KAAKkE,IAAIU,GAC5BC,EAAK/B,EAAMzD,EAAEuD,EAAQjB,IAAMjB,EAAG2D,EAAK1D,EAAG2D,GAAMjF,EAC5CyF,EAAKhC,EAAMxD,EAAEsD,EAAQhB,IAAMlB,EAAG4D,EAAK3D,EAAG0D,GAAM/E,EAC3C6D,EAGFA,GADE4B,GAAaF,EACN,KAAGC,EAAGH,GACbK,GAAaF,EACN,KAAGD,EAAGH,GAEN,IAAGG,EAAGH,KAASI,EAAGH,IAN3BxB,EAAQ,IAAG0B,KAAMC,IAOpBJ,EAAQG,EAAIF,EAAQG,EAExB3B,GAAQ,IAGVlG,KAAK+B,OACD0C,OAAO,YACPzC,KAAK,YAAa,aAAYI,KAAKC,MACnCL,KAAK,IAAKkE,GACVpB,KAAK9E,KAAKuE,QAAQQ,MAAMD,KAAK9E,KAAKkF,QAAQH,MAKjD,aACG,IAAIiD,EAAMhI,KAAKC,YAGfD,KAAK8B,UAEL,IAAImG,EAAKjI,KAAKiC,UAAU,IAAK+F,EAAIvH,IAC7ByH,EAAKlI,KAAKiC,UAAU,IAAK+F,EAAIrH,IAC7BmF,EAAK9F,KAAKiC,UAAU,IAAK+F,EAAIvH,GAAKuH,EAAIG,SAAWF,EACjDjC,EAAKhG,KAAKiC,UAAU,IAAK+F,EAAIrH,GAAKqH,EAAIG,SAAWD,EAErDlI,KAAK+B,OAAOC,KAAK,YAAa,aAAYiG,KAAMC,MAGhD,IAAIE,EAAKJ,EAAIK,WAAWC,OAAQC,EAAQ,EACpCC,EAAMR,EAAIS,eAAe1F,KAAK6D,GAAI,IAClC8B,EAAK3F,KAAKC,MAAM8C,EAAG/C,KAAKgE,IAAIyB,IAAMG,EAAK5F,KAAKC,MAAMgD,EAAGjD,KAAKkE,IAAIuB,IAElE,QAASjD,EAAI,EAAGA,EAAI6C,EAAI7C,IACrBgD,GAASP,EAAIK,WAAW9C,GAAGqD,OAE9B,QAASrD,EAAI,EAAGA,EAAI6C,EAAI7C,IAAK,CAC1B,IAAIsD,EAAQb,EAAIK,WAAW9C,GACvBhB,EAAU,IAAIC,KAAgB,CAACxC,KAAM6G,IACrC3D,EAAUlF,KAAKmF,cAAc0D,GAEjCL,GAAMK,EAAMD,OAAOL,EAAM,EAAExF,KAAK6D,GAChC,IAAIkC,EAAK/F,KAAKC,MAAM8C,EAAG/C,KAAKgE,IAAIyB,IAAMO,EAAKhG,KAAKC,MAAMgD,EAAGjD,KAAKkE,IAAIuB,IAElExI,KAAK+B,OACA0C,OAAO,YACPzC,KAAK,IAAM,QAAO0G,KAAMC,KAAM7C,KAAME,WAAY8C,KAAMC,MACtDjE,KAAKP,EAAQQ,MACbD,KAAKI,EAAQH,MAClB2D,EAAKI,EAAIH,EAAKI,GAMpB,aAEG,IAAIC,EAAMhJ,KAAKC,YAEXgJ,EADMjJ,KAAKkJ,aACMC,cAAcC,QAAQ,MAAM,EAC7C7E,EAAUvE,KAAK4F,cAAcoD,GAC7B9D,EAAUlF,KAAKmF,cAAc6D,GAGjChJ,KAAK8B,UAEL,IAAI4G,EAAK1I,KAAKiC,UAAU,IAAK+G,EAAItE,KAC7BoE,EAAK9I,KAAKiC,UAAU,IAAK+G,EAAIpE,KAC7B+D,EAAK3I,KAAKiC,UAAU,IAAK+G,EAAIrE,KAC7BoE,EAAK/I,KAAKiC,UAAU,IAAK+G,EAAInE,KAC7BwE,EAAKtG,KAAKE,IAAIyF,EAAGI,GAAKQ,EAAKvG,KAAKE,IAAI0F,EAAGI,GACvCQ,EAAKxG,KAAKyG,IAAIV,EAAGJ,GAAKe,EAAK1G,KAAKyG,IAAIb,EAAGI,GAW3C,IARK7D,EAAQQ,UAAYuD,IAAW1E,EAAQhC,MAAQ,QAEpDvC,KAAK+B,OACA0C,OAAO,YACPzC,KAAK,IAAM,IAAGqH,KAAMC,KAAMC,KAAME,MAAOF,MACvCzE,KAAKP,EAAQQ,MACbD,KAAKI,EAAQH,MAEdiE,EAAIU,aAAeV,EAAIW,aAAezE,EAAQ0E,WAAY,CAC3D,IAAIC,EAAMb,EAAIW,YAAaG,EAAMd,EAAIW,YACjCI,EAAS,IAAGV,KAAMC,KAAMC,MAAOM,KAAOC,KAAO,EAAED,EAAIN,KAAME,EAAG,EAAEK,MAAQD,KAAOC,KAC7EE,EAAS,IAAGX,EAAGE,KAAMD,EAAGG,MAAOA,MAAOI,KAAOC,KAAOL,EAAG,EAAEK,KAAO,EAAED,EAAIN,MAAOM,KAAOC,KAExF,GAAId,EAAIU,YAAc,EAAG,CAAE,IAAIO,EAAIF,EAAOA,EAAQC,EAAOA,EAAQC,EAEjEjK,KAAK+B,OAAO0C,OAAO,YACPzC,KAAK,IAAK+H,GACVjF,KAAKI,EAAQH,MACbmF,MAAM,QAAQC,QAAOjF,EAAQ3C,OAAO6H,SAAS,IAAKC,aAE9DrK,KAAK+B,OAAO0C,OAAO,YACdzC,KAAK,IAAKgI,GACVlF,KAAKI,EAAQH,MACbmF,MAAM,QAAQC,QAAOjF,EAAQ3C,OAAO+H,OAAO,IAAKD,cAM3D,aACG,IAAIE,EAASvK,KAAKC,YACduK,EAAM,IAAIC,IAAkBF,GAC5BG,GAAapJ,SAAI,IACjBC,EAAQgJ,EAAOlJ,QAAQqJ,GAG3B1K,KAAK8B,UAEL,IAAIM,EAAIpC,KAAKiC,UAAU,IAAKsI,EAAO9J,GAAIc,GACnCc,EAAIrC,KAAKiC,UAAU,IAAKsI,EAAO5J,GAAIY,GACnC2E,EAAOsE,EAAIG,OAAOvI,EAAEC,GAEpB6D,GACDlG,KAAK+B,OAAO0C,OAAO,YACdzC,KAAK,IAAKkE,GACVpB,KAAK0F,EAAIzF,MAKpB,aAGG/E,KAAK8B,UAEL,IAAI8I,EAAO5K,KAAKC,YACZuK,EAAM,IAAIC,IAAkBG,GAC5B1E,EAAO,GACPnB,EAAO/E,KAAKsF,mBAEhB,QAASC,EAAI,EAAGA,EAAIqF,EAAKC,KAAMtF,EAC5BW,GAAQsE,EAAIG,OAAO5F,EAAK3C,EAAEwI,EAAKnK,GAAG8E,IAAKR,EAAK1C,EAAEuI,EAAKjK,GAAG4E,KAErDW,GACDlG,KAAK+B,OAAO0C,OAAO,YACdzC,KAAK,IAAKkE,GACVpB,KAAK0F,EAAIzF,MAKpB,WAAqBf,EAAKC,EAAK6G,GAC5B,IAAI5G,EAAU,IAAI6G,KAAY/G,GAC1B7C,EAAO+C,EAAQ8G,YACfC,EAAM9J,EAAKsD,OAAO,OAAOzC,KAAK,MAAOiC,EAAIiH,OAAOlJ,KAAK,QAASiC,EAAI3B,QAAU2B,EAAIiH,OAEpF,OAAIJ,GAAOA,EAAI1B,QAAQ,UAAY,EAChC6B,EAAIf,MAAM,QAAQ,QAAQA,MAAM,SAAS,QACjCY,GAAOA,EAAI1B,QAAQ,WAAa,IACxCjI,EAAK+I,MAAM,WAAY,YACvBe,EAAIjJ,KAAK,QAAS,2FAGrBkC,EAAQiH,gBAEDjH,+HC9WV,WAAwBD,GAErBA,EAAImH,MAAQC,EAEZ,IAAIC,EAAQrH,EAAI3B,OAAQiJ,GAAY,EAAOC,EAAU,IACvC,SAAVF,IAAkBA,EAAQ,WAC1BrH,EAAIwH,UAA4C,iBAAzBxH,EAAIwH,SAASA,WACsB,GAAxDxH,EAAIwH,SAASA,SAASrC,QAAQ,0BAC/BmC,GAAY,EAAMC,EAAU,KAC5BF,EAAQrH,EAAIwH,SAASA,SAAS5C,MAAM,MAEpCyC,EAAQrH,EAAIwH,SAASA,SACrBD,EAAU,MAETvH,EAAIwH,SAASC,kBAAoBzH,EAAIwH,SAASE,SAC/C1H,EAAIwH,SAASE,QAAQC,QAAQC,IAC1B,IAAIC,EAAQ,IAAIC,OAAQ,OAAMF,EAAKG,YAAa,KAC5CC,EAAWhI,EAAIwH,SAASC,iBAAiBG,EAAKK,QAClDZ,EAAQA,EAAMa,QAAQL,EAAQG,EAAW,EAAM,IAAGA,KAAcA,MAKrE,aAAchI,GACfA,EAAImI,SAASR,QAAQS,IACnBf,EAAQA,EAAMgB,WAAWD,EAAMnB,MAAOmB,EAAM/J,UAGjDgJ,EAAQA,EAAMa,QAAQ,aAAc,cACtBA,QAAQ,kBAAmB,YAC3BA,QAAQ,kBAAmB,YAEzCb,EAAQA,EAAMa,QAAQ,YAAa,kCACrBA,QAAQ,UAAW,6BACnBA,QAAQ,WAAY,8BACpBA,QAAQ,UAAW,6BACnBA,QAAQ,YAAa,+BACrBA,QAAQ,aAAc,gCACtBA,QAAQ,WAAY,eACpBA,QAAQ,gBAAiB,eAEvC,QAASI,EAAI,EAAGA,EAAItI,EAAIuI,QAASD,EAC/BjB,EAAQA,EAAMgB,WAAWd,EAAUe,EAAI,IAAM,IAAGtI,EAAIwI,YAAYF,OAElEjB,EAAQA,EAAMa,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,cAAe,YACvBA,QAAQ,MAAO,WAC7B,QAAS5G,EAAI,EAAGA,EAAI,KAAMA,EACvB+F,EAAQA,EAAMgB,WAAY,KAAI/G,IAAM,cAAaA,MAEhDgG,GACDD,EAAQA,EAAMa,QAAQ,UAAU,KACV,QAAtBO,EAAQ9J,WACL0I,EAAQA,EAAMa,QAAQ,UAAU,KAChClI,EAAI0I,QAAU,IAAIC,SAAS,IAAK,IAAKtB,GAAOuB,KAAK5I,IAEjDA,EAAI0I,QAAU,IAAIC,SAAS,IAAKtB,GAAOuB,KAAK5I,IAG/CA,EAAI0I,QADsB,QAAtBD,EAAQ9J,UACE,IAAIgK,SAAS,IAAK,IAAK,UAAYtB,GAAOuB,KAAK5I,GAE/C,IAAI2I,SAAS,IAAK,UAAYtB,GAAOuB,KAAK5I,GAS7D,gBAAyBE,KAGtB2I,WAAWC,GACR,IAAIC,EAAMhN,KAAKC,YACXkB,EAAOnB,KAAKoB,kBACZ6L,EAAQ,EAAGC,EAAQ,EAEvB,GAAI/L,IAAS4L,EAAc,CACxB,IAAII,EAAKhM,EAAKiM,WAAWpN,KAAKqN,SAAUrN,KAAKsN,UAC7CL,EAAQE,EAAGI,WACXL,EAAQC,EAAGK,WAGd,IAAIC,EAAOT,EAAIU,MAAOC,EAAOX,EAAIY,MAAOC,GAAO,EAE3CZ,IAAUC,IACPD,EAAQQ,IAAMA,EAAOR,GACrBC,EAAQS,IAAMA,EAAOT,IAGxB/L,GAAQA,EAAK0M,MAASJ,EAAO,GAAOE,EAAO,IAC5CE,GAAO,EACPJ,EAAO1K,KAAK+K,IAAIL,GAChBE,EAAO5K,KAAK+K,IAAIH,IAGnB,IAAIpG,EAAKxE,KAAKgL,IAAIf,EAAIgB,KAAM,KACxBvK,GAAMkK,EAAOF,IAASlG,EAAK,GAC3B0G,EAAM,GAAIC,GAAU,EAGxB,KAFsBlB,EAAImB,MAAM7F,OAAS,GAAMyE,GAG5C,QAASxH,EAAI,EAAGA,EAAIgC,EAAIhC,IAAK,CAC1B,IAAInD,EAAIqL,EAAOlI,EAAE9B,EAAIpB,EAAI,EACrBwL,IAAMzL,EAAIW,KAAKqL,IAAIhM,IACvB,IACGC,EAAI2K,EAAIL,QAAQvK,SACXiM,GACLH,GAAU,EAGb,GAAIA,EAAS,MAETI,OAAOC,SAASlM,IACjB4L,EAAIO,KAAK,CAAEpM,EAAGC,MAKvB,IAAK6L,GAAWnB,IAAgBkB,EAAI3F,SAAY0E,EAAImB,MAAM7F,OAAS,EAAI,CAEpEf,EAAKyF,EAAImB,MAAM7F,OAAS,EACxBmF,EAAOT,EAAImB,MAAM5G,GACjBoG,EAAOX,EAAImB,MAAM5G,EAAG,GACpB0G,EAAM,GACNxK,EAAK,EACL,IAAIgL,EAAYzB,EAAI0B,QAAWjB,IAASE,EAAOgB,EAAM,EAEjDF,GACDhB,EAAOT,EAAImB,QAAQ5G,GACnBoH,EAAM3B,EAAI0B,OAAOE,OAAOC,QAAQpB,EAAM,IAEtChK,GAAMkK,EAAOF,IAASlG,EAAG,GAG5B,QAAShC,EAAI,EAAGA,EAAIgC,IAAMhC,EAAG,CAC1B,IAAInD,EAAIqM,EAAYzB,EAAI0B,OAAOE,OAAOE,aAAaH,EAAIpJ,EAAE,GAAKkI,EAAOhK,EAAG8B,EAExE,GAAK0H,IAAUC,IAAY9K,EAAI,EAAEqB,EAAKwJ,GAAW7K,EAAI,EAAEqB,EAAKyJ,GAAS,SACrE,IAAI7K,EAAI2K,EAAImB,MAAM5I,GAEd+I,OAAOC,SAASlM,IAAI4L,EAAIO,KAAK,CAAEpM,IAAGC,OAI5C,OAAO4L,EAIVc,mBAEG,IAAItB,EAAO,EAAGE,EAAO,EAAGqB,EAAO,EAAGC,EAAO,EACrCC,EAAOlP,KAAK8M,YAAW,IAEvBoC,iBAAM5G,UAEPmF,EAAOE,EAAOuB,EAAK,GAAG9M,EACtB4M,EAAOC,EAAOC,EAAK,GAAG7M,EAEtB6M,EAAKtD,QAAQ+C,IACVlB,EAAO1K,KAAKE,IAAI0L,EAAIvM,EAAGqL,GACvBE,EAAO5K,KAAKgL,IAAIY,EAAIvM,EAAGuL,GACvBqB,EAAOjM,KAAKE,IAAI0L,EAAItM,EAAG2M,GACvBC,EAAOlM,KAAKgL,IAAIY,EAAItM,EAAG4M,KAGtBA,EAAO,IAAKA,GAAS,EAAIE,yBACzBH,EAAO,IAAKA,GAAS,EAAIG,0BAGhC,IAAIC,GAAQzE,YAAO,QACfqC,EAAMhN,KAAKC,YAEfmP,SAAMlE,MAAQ8B,EAAI9B,MAAQ,QAC1BkE,EAAM9M,OAAS0K,EAAI1K,OAEnB8M,EAAMR,OAAOlB,MAAQD,EACrB2B,EAAMR,OAAOhB,MAAQD,EACrByB,EAAMC,OAAO3B,MAAQsB,EACrBI,EAAMC,OAAOzB,MAAQqB,EAErBG,EAAME,SAAWtC,EAAIsC,SACrBF,EAAMG,SAAWvC,EAAIuC,SAEdH,EAGVI,aAAavL,GACV,QAAKjE,KAAKyP,gBAAgBxL,KAC1ByL,OAAOC,OAAO3P,KAAKC,YAAagE,GAChC2L,EAAe5P,KAAKC,cACb,GAIV4P,oBAAoBC,GACjB,IAAIC,GAAU,EAQd,KANKD,IAAQ9P,KAAKkP,MAAQY,EAAIE,WAElBhQ,KAAKkP,KAAK5G,QAAWwH,EAAI1N,EAAIpC,KAAKkP,KAAK,GAAGe,KAASH,EAAI1N,EAAIpC,KAAKkP,KAAKlP,KAAKkP,KAAK5G,OAAO,GAAG2H,OAClGF,GAAU,GAGTA,EACD,OAAI/P,KAAK+B,QACN/B,KAAK+B,OAAOmO,OAAO,gBAAgBC,SAC/B,KAGV,IAA6BxB,EAAzB1L,EAAM,IAAQmN,GAAO,EAEzB,QAAQ7K,EAAI,EAAGA,EAAIvF,KAAKkP,KAAK5G,SAAU/C,EAAG,CACvCoJ,EAAM3O,KAAKkP,KAAK3J,GAChB,IAAI8K,EAAOtN,KAAKyG,IAAImF,EAAIsB,IAAMH,EAAI1N,GAC9BiO,EAAOpN,IAAOA,EAAMoN,EAAMD,EAAO7K,GAGxCoJ,EAAM3O,KAAKkP,KAAKkB,GAEhB,IAAIE,EAAOtQ,KAAK+B,OAAOmO,OAAO,gBAC1BK,EAASvQ,KAAKuE,QAAQiM,MAAQ,EAE9BF,EAAK5K,UACN4K,EAAOtQ,KAAK+B,OAAO0C,OAAO,cACPzC,KAAK,QAAQ,eACbkI,MAAM,iBAAiB,QACvBlI,KAAK,IAAKuO,GACVzL,KAAK9E,KAAKuE,QAAQQ,MAClBD,KAAK9E,KAAKkF,QAAQH,OAExC,IAAIkJ,EAAM,CAAEwC,KAAMzQ,KAAKC,YAAYiL,MACvBwF,MAAO1Q,KAAKC,YAAYqC,OACxBF,EAAGuM,EAAIsB,IACP5N,EAAGsM,EAAIgC,IACPC,OAAQ5Q,KAAKuE,QAAQhC,MACrBsO,OAAQ7Q,KAAKkF,QAAQ4L,eACrBC,MAAO,GACPC,MAAQjO,KAAKyG,IAAImF,EAAIsB,IAAMH,EAAI1N,GAAKmO,GAAYxN,KAAKyG,IAAImF,EAAIgC,IAAMb,EAAIzN,GAAKkO,GAExFtC,EAAIgD,QAAUX,EAAKY,SAAS,iBAAmBd,EAC/CnC,EAAIkD,KAAOlD,EAAI+C,MACf/C,EAAImD,UAAYrO,KAAKsO,KAAM1C,IAAIsB,IAAMH,EAAI1N,EAAI,GAAKuM,IAAIgC,IAAMb,EAAIzN,EAAI,IAEhE4L,EAAIgD,SACLX,EAAKtO,KAAK,KAAM2M,EAAIsB,KACfjO,KAAK,KAAM2M,EAAIgC,KACfO,SAAS,cAAed,GAEhC,IAAIK,EAAOzQ,KAAKsR,gBACZb,GAAMxC,EAAI8C,MAAMvC,KAAKiC,GAEzB,IAAIc,EAAQvR,KAAKoB,kBACbyE,EAAQ0L,iBAAOnE,WAAWpN,KAAKqN,SAAUrN,KAAKsN,UAClD,OAAIzH,GACDoI,EAAI8C,MAAMvC,KAAM,OAAM3I,EAAM2L,WAAW,IAAI7C,EAAIvM,UAAUyD,EAAM2L,WAAW,IAAI7C,EAAItM,MAE9E4L,EAIV7J,SAEG,IAAI4I,EAAMhN,KAAKC,YACXwR,EAAKzR,KAAKoB,kBACVd,EAAImR,EAAG9P,iBACP4P,EAAQvR,KAAK0R,iBAEjB1R,KAAK8B,SAAQ,GAGb9B,KAAKkP,KAAOlP,KAAK8M,YAAW,GAE5B9M,KAAK4F,cAAc,CAAE5D,KAAMgL,IAC3BhN,KAAKuE,QAAQoN,MAAO,EAEpB3R,KAAKmF,cAAc,CAAEnD,KAAMgL,EAAK4E,KAAM,IACtC5R,KAAKkF,QAAQyM,MAAO,EAEpB,IAAI9L,EAAQ4L,EAAGrE,WAAWpN,KAAKqN,SAAUrN,KAAKsN,UAG9C,QAAQ/H,EAAI,EAAGA,EAAIvF,KAAKkP,KAAK5G,SAAU/C,EAAG,CACvC,IAAIoJ,EAAM3O,KAAKkP,KAAK3J,GACpBoJ,EAAIsB,IAAMpK,EAAMoK,IAAItB,EAAIvM,GACxBuM,EAAIgC,IAAM9K,EAAM8K,IAAIhC,EAAItM,GAG3B,GAAIrC,KAAKkP,KAAK5G,OAAS,EAAG,CAEvB,IAAIuJ,EAAKvR,EACLiR,EAAMO,MAASP,EAAMO,MAAQ,IAC9BD,EAAK9O,KAAKC,MAAM6C,EAAM8K,IAAI,KACrBkB,EAAKvR,GAAOuR,EAAK,KAAIA,EAAKvR,IAGlC,IAAI4F,GAAO6L,QAAa,SAAU/R,KAAKkP,KAAM2C,EAAI,GAE5C7R,KAAKuE,QAAQmB,SACf1F,KAAK+B,OAAO0C,OAAO,YACdzC,KAAK,QAAS,QACdA,KAAK,IAAKkE,EAAKA,MACfgE,MAAM,OAAQ,QACdpF,KAAK9E,KAAKuE,QAAQQ,MAErB/E,KAAKkF,QAAQQ,SACf1F,KAAK+B,OAAO0C,OAAO,YACdzC,KAAK,QAAS,QACdA,KAAK,IAAKkE,EAAKA,KAAOA,EAAK8L,OAC3BlN,KAAK9E,KAAKkF,QAAQH,OAKhCkN,cAAcC,EAAKjP,EAAI8K,GACpB,GAAa,MAATmE,EAAc,OAAO,EAEzB,IAAIlF,EAAMhN,KAAKC,YAEf,GAAI+M,EAAImB,MAAM7F,OAAS,EAAG,CAGvB,IAAI6J,EAAYnF,EAAIgB,KAIpB,OAAOjL,KAAKyG,IAHDwD,EAAImB,MAAMgE,EAAY,GACtBnF,EAAImB,MAAMgE,EAAY,IAEFA,EAAYpP,KAAKyG,IAAIvG,EAAM8K,GAI7D,OAAO,cAIE/J,EAAKgJ,EAAKlC,GACnB,IAAI5G,EAAU,IAAIkO,EAAWpO,EAAKgJ,EAAKlC,GACnCuH,EAAI,IAAIC,KAAYxH,GACpByH,IAAarO,EAAQwN,iBACrBc,EAAO,OACXH,EAAEI,MAAM,QACJJ,EAAEI,MAAM,QAASD,GAAQ,KAAMtO,EAAQmJ,SAAWkF,GAClDF,EAAEI,MAAM,QAASD,GAAQ,KAAMtO,EAAQoJ,SAAWiF,GAClDF,EAAEI,MAAM,QAAOD,GAAQ,MACvBH,EAAEI,MAAM,QAAOD,GAAQ,MAE3B5C,EAAe5C,GAEf,IAAI0F,EAAKC,QAAQC,SAAQ,GAEzB,QAAKL,GAAYrO,EAAQmJ,UAAYnJ,EAAQoJ,YAC1CoF,EAAKG,SAAgB7O,EAAKE,EAAQ6K,mBAAoByD,IAElDE,EAAGtP,KAAK,KACZc,EAAQ4O,qBACR5O,EAAQE,SACDF,yECzWhB,gBAA4B6O,gBAIzBC,WAAWvB,EAAIwB,GAEZ,KAAKxB,EAAGhQ,QAAWgQ,EAAGxB,KAAQwB,EAAGd,KAAQc,EAAGyB,KAAQzB,EAAG0B,UACpD,OAAOC,QAAQtF,IAAI,0CAEtB,GAAI2D,EAAG4B,WAAa5B,EAAG6B,YAChBtT,KAAKuT,QAAQC,MAAQ/B,EAAG4B,WAAerT,KAAKuT,QAAQC,MAAQ/B,EAAG6B,WAAY,OAElF,IAAIG,EAAWzT,KAAK0T,aAAa,KAC7B1H,EAAQ,EAAG2H,EAAOF,EAASnL,OAAO,EAEtC,GAAImJ,EAAGmC,WAAanC,EAAGoC,UAAW,CAC/B,KAAQ7H,EAAQ2H,GAAUF,EAASzH,GAAO5J,EAAIqP,EAAGmC,WAAY5H,IAC7D,KAAQA,EAAQ2H,GAAUF,EAASE,GAAMvR,EAAIqP,EAAGoC,WAAYF,IAG/D,GAAI3H,GAAS2H,EAAM,OAEnB,IAAIG,EAAO,GAAI7D,EAAMwB,EAAGxB,IAAIjQ,KAAKuT,QAAQC,OACrCO,EAAKN,EAASzH,GAElB,QAASzG,EAAIyG,EAAQ,EAAGzG,GAAKoO,IAAQpO,EAAG,CACrC,IAAIyO,EAAKP,EAASlO,GAClBuO,EAAKtF,KAAKyB,EAAKwB,EAAGd,IAAIoD,EAAG3R,GAAIqP,EAAGyB,IAAIa,EAAG1R,GAC7B4N,EAAKwB,EAAGd,IAAIqD,EAAG5R,GAAIqP,EAAGyB,IAAIc,EAAG3R,IACvC0R,EAAKC,EAGR,IAAIjD,GAAQkD,QAAmBH,GAAMI,QAAqBlU,KAAMiT,IAEhExB,EAAG0B,SAASgB,IAAIpD,GAEhBU,EAAG2C,SAAS,KAKfC,gBACG,IAAIjF,EAAQpP,KAAKsU,kBACjB,OAAOzB,kBAAgB7S,KAAKuU,SAAUnF,EAAOpP,KAAKuT,QAAQiB,kBAGjDxQ,EAAKiP,EAAOnI,GACrB,OAAO2J,EAAcC,WAAW,IAAID,EAAczQ,EAAKiP,GAAQnI","names":["text","this","getObject","pp","getPadPainter","w","getPadWidth","h","getPadHeight","pos_x","fX","pos_y","fY","tcolor","getColor","fTextColor","use_frame","fact","textsize","fTextSize","main","getFramePainter","TestBit","BIT","isndc","p","mode3d","getFrameWidth","getFrameHeight","getRootPad","fTextAlign","createG","draw_g","attr","axisToSvg","arg","align","x","y","fTitle","color","latex","fTextAngle","rotate","t","_typename","startTextDrawing","fTextFont","Math","round","min","drawText","finishTextDrawing","then","isBatchMode","pos_dx","pos_dy","moveDrag","dx","dy","moveEnd","not_changed","svgToAxis","submitCanvExec","addMoveHandler","dom","obj","painter","ObjectPainter","redraw","kLineNDC","line","lineatt","TAttLineHandler","append","fX1","fY1","fX2","fY2","call","func","ensureTCanvas","polyline","fillatt","createAttFill","kPolyLineNDC","cmd","getAxisToSvgFunc","n","fLastPoint","setSolidColor","empty","ellipse","createAttLine","funcs","rx","fR1","ry","fR2","path","closed_ellipse","fPhimin","fPhimax","rx1","ry2","ry1","rx2","large_arc","a1","PI","a2","dx1","cos","dy1","sin","dy4","fTheta","ct","st","phi1","np","dphi","lastx","lasty","angle","px","py","v","O","pie","xc","yc","fRadius","nb","fPieSlices","length","total","af","fAngularOffset","x1","y1","fValue","slice","x2","y2","box","draw_line","getDrawOpt","toUpperCase","indexOf","xx","yy","ww","abs","hh","fBorderMode","fBorderSize","hasColor","pww","phh","side1","side2","s","style","d3_rgb","brighter","formatHex","darker","marker","att","TAttMarkerHandler","kMarkerNDC","create","poly","fN","opt","BasePainter","selectDom","img","fName","setTopPainter","_math","jsroot_math","_func","isformula","pprefix","fFormula","fClingParameters","fParams","forEach","pair","regex","RegExp","first","parvalue","second","replace","formulas","entry","replaceAll","i","fNpar","GetParValue","c","evalPar","Function","bind","createBins","ignore_zoom","tf1","gxmin","gxmax","gr","getGrFuncs","second_x","second_y","scale_xmin","scale_xmax","xmin","fXmin","xmax","fXmax","logx","log","max","fNpx","res","iserror","fSave","exp","err","Number","isFinite","push","use_histo","$histo","bin","fXaxis","FindBin","GetBinCenter","createDummyHisto","ymin","ymax","bins","gStyle","histo","fYaxis","fMinimum","fMaximum","updateObject","matchObjectType","Object","assign","proivdeEvalPar","processTooltipEvent","pnt","cleanup","disabled","grx","select","remove","best","dist","gbin","radius","width","name","title","gry","color1","color2","getFillColor","lines","exact","changed","property","menu","menu_dist","sqrt","getObjectHint","pmain","axisAsText","fp","getMainPainter","used","kind","h0","hmin","buildSvgPath","close","canZoomInside","axis","nb_points","TF1Painter","d","DrawOptions","has_main","aopt","check","pr","Promise","resolve","TH1Painter","addToPadPrimitives","TGraphPainter2D","drawBins3D","graph","grz","toplevel","console","zoom_xmin","zoom_xmax","options","pos3d","drawbins","optimizeBins","last","zoom_ymin","zoom_ymax","pnts","p0","p1","createLineSegments","create3DLineMaterial","add","render3D","drawAxisHisto","createHistogram","getDom","Axis","TGraphPainter","_drawGraph"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/more.mjs","../node_modules/jsroot/modules/hist/TF1Painter.mjs","../node_modules/jsroot/modules/hist/TGraphPainter.mjs"],"sourcesContent":["import { BIT, isBatchMode } from '../core.mjs';\nimport { rgb as d3_rgb } from '../d3.mjs';\nimport { BasePainter } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TAttMarkerHandler } from '../base/TAttMarkerHandler.mjs';\nimport { TAttLineHandler } from '../base/TAttLineHandler.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\nimport { addMoveHandler } from '../gui/utils.mjs';\n\n\n/** @summary Draw TText\n  * @private */\nfunction drawText() {\n   let text = this.getObject(),\n       pp = this.getPadPainter(),\n       w = pp.getPadWidth(),\n       h = pp.getPadHeight(),\n       pos_x = text.fX, pos_y = text.fY,\n       tcolor = this.getColor(text.fTextColor),\n       use_frame = false,\n       fact = 1., textsize = text.fTextSize || 0.05,\n       main = this.getFramePainter();\n\n   if (text.TestBit(BIT(14))) {\n      // NDC coordinates\n      this.isndc = true;\n   } else if (main && !main.mode3d) {\n      // frame coordiantes\n      w = main.getFrameWidth();\n      h = main.getFrameHeight();\n      use_frame = \"upper_layer\";\n   } else if (pp.getRootPad(true)) {\n      // force pad coordiantes\n   } else {\n      // place in the middle\n      this.isndc = true;\n      pos_x = pos_y = 0.5;\n      text.fTextAlign = 22;\n      if (!tcolor) tcolor = 'black';\n   }\n\n   this.createG(use_frame);\n\n   this.draw_g.attr(\"transform\", null); // remove transofrm from interactive changes\n\n   this.pos_x = this.axisToSvg(\"x\", pos_x, this.isndc);\n   this.pos_y = this.axisToSvg(\"y\", pos_y, this.isndc);\n\n   let arg = { align: text.fTextAlign, x: this.pos_x, y: this.pos_y, text: text.fTitle, color: tcolor, latex: 0 };\n\n   if (text.fTextAngle) arg.rotate = -text.fTextAngle;\n\n   if (text._typename == 'TLatex') { arg.latex = 1; fact = 0.9; } else\n   if (text._typename == 'TMathText') { arg.latex = 2; fact = 0.8; }\n\n   this.startTextDrawing(text.fTextFont, Math.round((textsize>1) ? textsize : textsize*Math.min(w,h)*fact));\n\n   this.drawText(arg);\n\n   return this.finishTextDrawing().then(() => {\n      if (isBatchMode()) return this;\n\n      this.pos_dx = this.pos_dy = 0;\n\n      if (!this.moveDrag)\n         this.moveDrag = function(dx,dy) {\n            this.pos_dx += dx;\n            this.pos_dy += dy;\n            this.draw_g.attr(\"transform\", `translate(${this.pos_dx},${this.pos_dy})`);\n        }\n\n      if (!this.moveEnd)\n         this.moveEnd = function(not_changed) {\n            if (not_changed) return;\n            let text = this.getObject();\n            text.fX = this.svgToAxis(\"x\", this.pos_x + this.pos_dx, this.isndc),\n            text.fY = this.svgToAxis(\"y\", this.pos_y + this.pos_dy, this.isndc);\n            this.submitCanvExec(`SetX(${text.fX});;SetY(${text.fY});;`);\n         }\n\n      addMoveHandler(this);\n\n      return this;\n   });\n}\n\n/** @summary Draw TLine\n  * @private */\nfunction drawTLine(dom, obj) {\n\n   let painter = new ObjectPainter(dom, obj);\n\n   painter.redraw = function() {\n      const kLineNDC = BIT(14),\n            line = this.getObject(),\n            lineatt = new TAttLineHandler(line),\n            isndc = line.TestBit(kLineNDC);\n\n      // create svg:g container for line drawing\n      this.createG();\n\n      this.draw_g\n          .append(\"svg:path\")\n          .attr(\"d\", `M${this.axisToSvg(\"x\", line.fX1, isndc)},${this.axisToSvg(\"y\", line.fY1, isndc)}L${this.axisToSvg(\"x\", line.fX2, isndc)},${this.axisToSvg(\"y\", line.fY2, isndc)}`)\n          .call(lineatt.func);\n\n      return this;\n   }\n\n   return ensureTCanvas(painter, false).then(() => painter.redraw());\n}\n\n/** @summary Draw TPolyLine\n  * @private */\nfunction drawPolyLine() {\n\n   // create svg:g container for polyline drawing\n   this.createG();\n\n   let polyline = this.getObject(),\n       lineatt = new TAttLineHandler(polyline),\n       fillatt = this.createAttFill(polyline),\n       kPolyLineNDC = BIT(14),\n       isndc = polyline.TestBit(kPolyLineNDC),\n       cmd = \"\", func = this.getAxisToSvgFunc(isndc);\n\n   for (let n = 0; n <= polyline.fLastPoint; ++n)\n      cmd += ((n > 0) ? \"L\" : \"M\") + func.x(polyline.fX[n]) + \",\" + func.y(polyline.fY[n]);\n\n   if (polyline._typename != \"TPolyLine\") fillatt.setSolidColor(\"none\");\n\n   if (!fillatt.empty()) cmd+=\"Z\";\n\n   this.draw_g\n       .append(\"svg:path\")\n       .attr(\"d\", cmd)\n       .call(lineatt.func)\n       .call(fillatt.func);\n}\n\n/** @summary Draw TEllipse\n  * @private */\nfunction drawEllipse() {\n\n   let ellipse = this.getObject();\n\n   this.createAttLine({ attr: ellipse });\n   this.createAttFill({ attr: ellipse });\n\n   // create svg:g container for ellipse drawing\n   this.createG();\n\n   let funcs = this.getAxisToSvgFunc(),\n       x = funcs.x(ellipse.fX1),\n       y = funcs.y(ellipse.fY1),\n       rx = funcs.x(ellipse.fX1 + ellipse.fR1) - x,\n       ry = y - funcs.y(ellipse.fY1 + ellipse.fR2),\n       path = \"\", closed_ellipse = (ellipse.fPhimin == 0) && (ellipse.fPhimax == 360);\n\n   // handle same as ellipse with equal radius\n   if ((ellipse._typename == \"TCrown\") && (ellipse.fR1 <= 0))\n      rx = funcs.x(ellipse.fX1 + ellipse.fR2) - x;\n\n   if ((ellipse._typename == \"TCrown\") && (ellipse.fR1 > 0)) {\n      let rx1 = rx, ry2 = ry,\n          ry1 = y - funcs.y(ellipse.fY1 + ellipse.fR1),\n          rx2 = funcs.x(ellipse.fX1 + ellipse.fR2) - x;\n\n      if (closed_ellipse) {\n         path = `M${-rx1},0A${rx1},${ry1},0,1,0,${rx1},0A${rx1},${ry1},0,1,0,${-rx1},0` +\n                `M${-rx2},0A${rx2},${ry2},0,1,0,${rx2},0A${rx2},${ry2},0,1,0,${-rx2},0`;\n      } else {\n         let large_arc = (ellipse.fPhimax-ellipse.fPhimin>=180) ? 1 : 0,\n             a1 = ellipse.fPhimin*Math.PI/180, a2 = ellipse.fPhimax*Math.PI/180,\n             dx1 = Math.round(rx1*Math.cos(a1)), dy1 = Math.round(ry1*Math.sin(a1)),\n             dx2 = Math.round(rx1*Math.cos(a2)), dy2 = Math.round(ry1*Math.sin(a2)),\n             dx3 = Math.round(rx2*Math.cos(a1)), dy3 = Math.round(ry2*Math.sin(a1)),\n             dx4 = Math.round(rx2*Math.cos(a2)), dy4 = Math.round(ry2*Math.sin(a2));\n\n         path = `M${dx2},${dy2}A${rx1},${ry1},0,${large_arc},0,${dx1},${dy1}` +\n                `L${dx3},${dy3}A${rx2},${ry2},0,${large_arc},1,${dx4},${dy4}Z`;\n      }\n   } else if (ellipse.fTheta == 0) {\n      if (closed_ellipse) {\n         path = `M${-rx},0A${rx},${ry},0,1,0,${rx},0A${rx},${ry},0,1,0,${-rx},0Z`;\n      } else {\n         let x1 = Math.round(rx * Math.cos(ellipse.fPhimin*Math.PI/180)),\n             y1 = Math.round(ry * Math.sin(ellipse.fPhimin*Math.PI/180)),\n             x2 = Math.round(rx * Math.cos(ellipse.fPhimax*Math.PI/180)),\n             y2 = Math.round(ry * Math.sin(ellipse.fPhimax*Math.PI/180));\n         path = `M0,0L${x1},${y1}A${rx},${ry},0,1,1,${x2},${y2}Z`;\n      }\n   } else {\n     let ct = Math.cos(ellipse.fTheta*Math.PI/180),\n         st = Math.sin(ellipse.fTheta*Math.PI/180),\n         phi1 = ellipse.fPhimin*Math.PI/180,\n         phi2 = ellipse.fPhimax*Math.PI/180,\n         np = 200,\n         dphi = (phi2-phi1) / (np - (closed_ellipse ? 0 : 1)),\n         lastx = 0, lasty = 0;\n     if (!closed_ellipse) path = \"M0,0\";\n     for (let n = 0; n < np; ++n) {\n         let angle = phi1 + n*dphi,\n             dx = ellipse.fR1 * Math.cos(angle),\n             dy = ellipse.fR2 * Math.sin(angle),\n             px = funcs.x(ellipse.fX1 + dx*ct - dy*st) - x,\n             py = funcs.y(ellipse.fY1 + dx*st + dy*ct) - y;\n         if (!path)\n            path = `M${px},${py}`;\n         else if (lastx == px)\n            path += `v${py-lasty}`;\n         else if (lasty == py)\n            path += `h${px-lastx}`;\n         else\n            path += `l${px-lastx},${py-lasty}`;\n         lastx = px; lasty = py;\n     }\n     path += \"Z\";\n   }\n\n   this.draw_g\n      .append(\"svg:path\")\n      .attr(\"transform\",`translate(${x},${y})`)\n      .attr(\"d\", path)\n      .call(this.lineatt.func).call(this.fillatt.func);\n}\n\n/** @summary Draw TPie\n  * @private */\nfunction drawPie() {\n   let pie = this.getObject();\n\n   // create svg:g container for ellipse drawing\n   this.createG();\n\n   let xc = this.axisToSvg(\"x\", pie.fX),\n       yc = this.axisToSvg(\"y\", pie.fY),\n       rx = this.axisToSvg(\"x\", pie.fX + pie.fRadius) - xc,\n       ry = this.axisToSvg(\"y\", pie.fY + pie.fRadius) - yc;\n\n   this.draw_g.attr(\"transform\",`translate(${xc},${yc})`);\n\n   // Draw the slices\n   let nb = pie.fPieSlices.length, total = 0,\n       af = (pie.fAngularOffset*Math.PI)/180,\n       x1 = Math.round(rx*Math.cos(af)), y1 = Math.round(ry*Math.sin(af));\n\n   for (let n = 0; n < nb; n++)\n      total += pie.fPieSlices[n].fValue;\n\n   for (let n = 0; n < nb; n++) {\n      let slice = pie.fPieSlices[n],\n          lineatt = new TAttLineHandler({attr: slice}),\n          fillatt = this.createAttFill(slice);\n\n      af += slice.fValue/total*2*Math.PI;\n      let x2 = Math.round(rx*Math.cos(af)), y2 = Math.round(ry*Math.sin(af));\n\n      this.draw_g\n          .append(\"svg:path\")\n          .attr(\"d\", `M0,0L${x1},${y1}A${rx},${ry},0,0,0,${x2},${y2}z`)\n          .call(lineatt.func)\n          .call(fillatt.func);\n      x1 = x2; y1 = y2;\n   }\n}\n\n/** @summary Draw TBox\n  * @private */\nfunction drawBox() {\n\n   let box = this.getObject(),\n       opt = this.getDrawOpt(),\n       draw_line = (opt.toUpperCase().indexOf(\"L\")>=0),\n       lineatt = this.createAttLine(box),\n       fillatt = this.createAttFill(box);\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let x1 = this.axisToSvg(\"x\", box.fX1),\n       x2 = this.axisToSvg(\"x\", box.fX2),\n       y1 = this.axisToSvg(\"y\", box.fY1),\n       y2 = this.axisToSvg(\"y\", box.fY2),\n       xx = Math.min(x1,x2), yy = Math.min(y1,y2),\n       ww = Math.abs(x2-x1), hh = Math.abs(y1-y2);\n\n   // if box filled, contour line drawn only with \"L\" draw option:\n   if (!fillatt.empty() && !draw_line) lineatt.color = \"none\";\n\n   this.draw_g\n       .append(\"svg:path\")\n       .attr(\"d\", `M${xx},${yy}h${ww}v${hh}h${-ww}z`)\n       .call(lineatt.func)\n       .call(fillatt.func);\n\n   if (box.fBorderMode && box.fBorderSize && fillatt.hasColor()) {\n      let pww = box.fBorderSize, phh = box.fBorderSize,\n          side1 = `M${xx},${yy}h${ww}l${-pww},${phh}h${2*pww-ww}v${hh-2*phh}l${-pww},${phh}z`,\n          side2 = `M${xx+ww},${yy+hh}v${-hh}l${-pww},${phh}v${hh-2*phh}h${2*pww-ww}l${-pww},${phh}z`;\n\n      if (box.fBorderMode < 0) { let s = side1; side1 = side2; side2 = s; }\n\n      this.draw_g.append(\"svg:path\")\n                 .attr(\"d\", side1)\n                 .call(fillatt.func)\n                 .style(\"fill\", d3_rgb(fillatt.color).brighter(0.5).formatHex());\n\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", side2)\n          .call(fillatt.func)\n          .style(\"fill\", d3_rgb(fillatt.color).darker(0.5).formatHex());\n   }\n}\n\n/** @summary Draw TMarker\n  * @private */\nfunction drawMarker() {\n   let marker = this.getObject(),\n       att = new TAttMarkerHandler(marker),\n       kMarkerNDC = BIT(14),\n       isndc = marker.TestBit(kMarkerNDC);\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let x = this.axisToSvg(\"x\", marker.fX, isndc),\n       y = this.axisToSvg(\"y\", marker.fY, isndc),\n       path = att.create(x,y);\n\n   if (path)\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", path)\n          .call(att.func);\n}\n\n/** @summary Draw TPolyMarker\n  * @private */\nfunction drawPolyMarker() {\n\n   // create svg:g container for box drawing\n   this.createG();\n\n   let poly = this.getObject(),\n       att = new TAttMarkerHandler(poly),\n       path = \"\",\n       func = this.getAxisToSvgFunc();\n\n   for (let n = 0; n < poly.fN; ++n)\n      path += att.create(func.x(poly.fX[n]), func.y(poly.fY[n]));\n\n   if (path)\n      this.draw_g.append(\"svg:path\")\n          .attr(\"d\", path)\n          .call(att.func);\n}\n\n/** @summary Draw JS image\n  * @private */\nfunction drawJSImage(dom, obj, opt) {\n   let painter = new BasePainter(dom),\n       main = painter.selectDom(),\n       img = main.append(\"img\").attr(\"src\", obj.fName).attr(\"title\", obj.fTitle || obj.fName);\n\n   if (opt && opt.indexOf(\"scale\") >= 0) {\n      img.style(\"width\",\"100%\").style(\"height\",\"100%\");\n   } else if (opt && opt.indexOf(\"center\") >= 0) {\n      main.style(\"position\", \"relative\");\n      img.attr(\"style\", \"margin: 0; position: absolute;  top: 50%; left: 50%; transform: translate(-50%, -50%);\");\n   }\n\n   painter.setTopPainter();\n\n   return painter;\n}\n\nexport { drawText, drawTLine, drawPolyLine, drawEllipse, drawPie, drawBox,\n         drawMarker, drawPolyMarker, drawJSImage };\n","import { create, gStyle } from '../core.mjs';\nimport { DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport * as jsroot_math from '../base/math.mjs';\n\n\nfunction proivdeEvalPar(obj) {\n\n   obj._math = jsroot_math;\n\n   let _func = obj.fTitle, isformula = false, pprefix = \"[\";\n   if (_func === \"gaus\") _func = \"gaus(0)\";\n   if (obj.fFormula && typeof obj.fFormula.fFormula == \"string\") {\n     if (obj.fFormula.fFormula.indexOf(\"[](double*x,double*p)\")==0) {\n        isformula = true; pprefix = \"p[\";\n        _func = obj.fFormula.fFormula.slice(21);\n     } else {\n        _func = obj.fFormula.fFormula;\n        pprefix = \"[p\";\n     }\n     if (obj.fFormula.fClingParameters && obj.fFormula.fParams)\n        obj.fFormula.fParams.forEach(pair => {\n           let regex = new RegExp(`(\\\\[${pair.first}\\\\])`, 'g'),\n               parvalue = obj.fFormula.fClingParameters[pair.second];\n           _func = _func.replace(regex, (parvalue < 0) ? `(${parvalue})` : parvalue);\n        });\n\n  }\n\n  if ('formulas' in obj)\n     obj.formulas.forEach(entry => {\n       _func = _func.replaceAll(entry.fName, entry.fTitle);\n     });\n\n  _func = _func.replace(/\\b(abs)\\b/g, 'TMath::Abs')\n               .replace(/\\b(TMath::Exp)/g, 'Math.exp')\n               .replace(/\\b(TMath::Abs)/g, 'Math.abs');\n\n  _func = _func.replace(/xygaus\\(/g, 'this._math.gausxy(this, x, y, ')\n               .replace(/gaus\\(/g, 'this._math.gaus(this, x, ')\n               .replace(/gausn\\(/g, 'this._math.gausn(this, x, ')\n               .replace(/expo\\(/g, 'this._math.expo(this, x, ')\n               .replace(/landau\\(/g, 'this._math.landau(this, x, ')\n               .replace(/landaun\\(/g, 'this._math.landaun(this, x, ')\n               .replace(/TMath::/g, 'this._math.')\n               .replace(/ROOT::Math::/g, 'this._math.');\n\n  for (let i = 0; i < obj.fNpar; ++i)\n    _func = _func.replaceAll(pprefix + i + \"]\", `(${obj.GetParValue(i)})`);\n\n  _func = _func.replace(/\\b(sin)\\b/gi, 'Math.sin')\n               .replace(/\\b(cos)\\b/gi, 'Math.cos')\n               .replace(/\\b(tan)\\b/gi, 'Math.tan')\n               .replace(/\\b(exp)\\b/gi, 'Math.exp')\n               .replace(/\\b(pow)\\b/gi, 'Math.pow')\n               .replace(/pi/g, 'Math.PI');\n  for (let n = 2; n < 10; ++n)\n     _func = _func.replaceAll(`x^${n}`, `Math.pow(x,${n})`);\n\n  if (isformula) {\n     _func = _func.replace(/x\\[0\\]/g,\"x\");\n     if (obj._typename === \"TF2\") {\n        _func = _func.replace(/x\\[1\\]/g,\"y\");\n        obj.evalPar = new Function(\"x\", \"y\", _func).bind(obj);\n     } else {\n        obj.evalPar = new Function(\"x\", _func).bind(obj);\n     }\n  } else if (obj._typename === \"TF2\")\n     obj.evalPar = new Function(\"x\", \"y\", \"return \" + _func).bind(obj);\n  else\n     obj.evalPar = new Function(\"x\", \"return \" + _func).bind(obj);\n}\n\n/**\n  * @summary Painter for TF1 object\n  *\n  * @private\n  */\n\nclass TF1Painter extends ObjectPainter {\n\n   /** @summary Create bins for TF1 drawing */\n   createBins(ignore_zoom) {\n      let tf1 = this.getObject(),\n          main = this.getFramePainter(),\n          gxmin = 0, gxmax = 0;\n\n      if (main && !ignore_zoom)  {\n         let gr = main.getGrFuncs(this.second_x, this.second_y);\n         gxmin = gr.scale_xmin;\n         gxmax = gr.scale_xmax;\n      }\n\n      let xmin = tf1.fXmin, xmax = tf1.fXmax, logx = false;\n\n      if (gxmin !== gxmax) {\n         if (gxmin > xmin) xmin = gxmin;\n         if (gxmax < xmax) xmax = gxmax;\n      }\n\n      if (main && main.logx && (xmin > 0) && (xmax > 0)) {\n         logx = true;\n         xmin = Math.log(xmin);\n         xmax = Math.log(xmax);\n      }\n\n      let np = Math.max(tf1.fNpx, 101),\n          dx = (xmax - xmin) / (np - 1),\n          res = [], iserror = false,\n          force_use_save = (tf1.fSave.length > 3) && ignore_zoom;\n\n      if (!force_use_save)\n         for (let n = 0; n < np; n++) {\n            let x = xmin + n*dx, y = 0;\n            if (logx) x = Math.exp(x);\n            try {\n               y = tf1.evalPar(x);\n            } catch(err) {\n               iserror = true;\n            }\n\n            if (iserror) break;\n\n            if (Number.isFinite(y))\n               res.push({ x, y });\n         }\n\n      // in the case there were points have saved and we cannot calculate function\n      // if we don't have the user's function\n      if ((iserror || ignore_zoom || !res.length) && (tf1.fSave.length > 3)) {\n\n         np = tf1.fSave.length - 2;\n         xmin = tf1.fSave[np];\n         xmax = tf1.fSave[np+1];\n         res = [];\n         dx = 0;\n         let use_histo = tf1.$histo && (xmin === xmax), bin = 0;\n\n         if (use_histo) {\n            xmin = tf1.fSave[--np];\n            bin = tf1.$histo.fXaxis.FindBin(xmin, 0);\n         } else {\n            dx = (xmax - xmin) / (np-1);\n         }\n\n         for (let n = 0; n < np; ++n) {\n            let x = use_histo ? tf1.$histo.fXaxis.GetBinCenter(bin+n+1) : xmin + dx*n;\n            // check if points need to be displayed at all, keep at least 4-5 points for Bezier curves\n            if ((gxmin !== gxmax) && ((x + 2*dx < gxmin) || (x - 2*dx > gxmax))) continue;\n            let y = tf1.fSave[n];\n\n            if (Number.isFinite(y)) res.push({ x, y });\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Create histogram for axes drawing */\n   createDummyHisto() {\n\n      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n          bins = this.createBins(true);\n\n      if (bins?.length) {\n\n         xmin = xmax = bins[0].x;\n         ymin = ymax = bins[0].y;\n\n         bins.forEach(bin => {\n            xmin = Math.min(bin.x, xmin);\n            xmax = Math.max(bin.x, xmax);\n            ymin = Math.min(bin.y, ymin);\n            ymax = Math.max(bin.y, ymax);\n         });\n\n         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);\n         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);\n      }\n\n      let histo = create(\"TH1I\"),\n          tf1 = this.getObject();\n\n      histo.fName = tf1.fName + \"_hist\";\n      histo.fTitle = tf1.fTitle;\n\n      histo.fXaxis.fXmin = xmin;\n      histo.fXaxis.fXmax = xmax;\n      histo.fYaxis.fXmin = ymin;\n      histo.fYaxis.fXmax = ymax;\n\n      histo.fMinimum = tf1.fMinimum;\n      histo.fMaximum = tf1.fMaximum;\n\n      return histo;\n   }\n\n   updateObject(obj /*, opt */) {\n      if (!this.matchObjectType(obj)) return false;\n      Object.assign(this.getObject(), obj);\n      proivdeEvalPar(this.getObject());\n      return true;\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      let cleanup = false;\n\n      if (!pnt || !this.bins || pnt.disabled) {\n         cleanup = true;\n      } else if (!this.bins.length || (pnt.x < this.bins[0].grx) || (pnt.x > this.bins[this.bins.length-1].grx)) {\n         cleanup = true;\n      }\n\n      if (cleanup) {\n         if (this.draw_g)\n            this.draw_g.select(\".tooltip_bin\").remove();\n         return null;\n      }\n\n      let min = 100000, best = -1, bin;\n\n      for(let n = 0; n < this.bins.length; ++n) {\n         bin = this.bins[n];\n         let dist = Math.abs(bin.grx - pnt.x);\n         if (dist < min) { min = dist; best = n; }\n      }\n\n      bin = this.bins[best];\n\n      let gbin = this.draw_g.select(\".tooltip_bin\"),\n          radius = this.lineatt.width + 3;\n\n      if (gbin.empty())\n         gbin = this.draw_g.append(\"svg:circle\")\n                           .attr(\"class\",\"tooltip_bin\")\n                           .style(\"pointer-events\",\"none\")\n                           .attr(\"r\", radius)\n                           .call(this.lineatt.func)\n                           .call(this.fillatt.func);\n\n      let res = { name: this.getObject().fName,\n                  title: this.getObject().fTitle,\n                  x: bin.grx,\n                  y: bin.gry,\n                  color1: this.lineatt.color,\n                  color2: this.fillatt.getFillColor(),\n                  lines: [],\n                  exact: (Math.abs(bin.grx - pnt.x) < radius) && (Math.abs(bin.gry - pnt.y) < radius) };\n\n      res.changed = gbin.property(\"current_bin\") !== best;\n      res.menu = res.exact;\n      res.menu_dist = Math.sqrt((bin.grx - pnt.x)**2 + (bin.gry - pnt.y)**2);\n\n      if (res.changed)\n         gbin.attr(\"cx\", bin.grx)\n             .attr(\"cy\", bin.gry)\n             .property(\"current_bin\", best);\n\n      let name = this.getObjectHint();\n      if (name) res.lines.push(name);\n\n      let pmain = this.getFramePainter(),\n          funcs = pmain?.getGrFuncs(this.second_x, this.second_y);\n      if (funcs)\n         res.lines.push(`x = ${funcs.axisAsText(\"x\",bin.x)} y = ${funcs.axisAsText(\"y\",bin.y)}`);\n\n      return res;\n   }\n\n   /** @summary Redraw function */\n   redraw() {\n\n      let tf1 = this.getObject(),\n          fp = this.getFramePainter(),\n          h = fp.getFrameHeight(),\n          pmain = this.getMainPainter();\n\n      this.createG(true);\n\n      // recalculate drawing bins when necessary\n      this.bins = this.createBins(false);\n\n      this.createAttLine({ attr: tf1 });\n      this.lineatt.used = false;\n\n      this.createAttFill({ attr: tf1, kind: 1 });\n      this.fillatt.used = false;\n\n      let funcs = fp.getGrFuncs(this.second_x, this.second_y);\n\n      // first calculate graphical coordinates\n      for(let n = 0; n < this.bins.length; ++n) {\n         let bin = this.bins[n];\n         bin.grx = funcs.grx(bin.x);\n         bin.gry = funcs.gry(bin.y);\n      }\n\n      if (this.bins.length > 2) {\n\n         let h0 = h;  // use maximal frame height for filling\n         if (pmain.hmin && (pmain.hmin >= 0)) {\n            h0 = Math.round(funcs.gry(0));\n            if ((h0 > h) || (h0 < 0)) h0 = h;\n         }\n\n         let path = buildSvgPath(\"bezier\", this.bins, h0, 2);\n\n         if (!this.lineatt.empty())\n            this.draw_g.append(\"svg:path\")\n                .attr(\"class\", \"line\")\n                .attr(\"d\", path.path)\n                .style(\"fill\", \"none\")\n                .call(this.lineatt.func);\n\n         if (!this.fillatt.empty())\n            this.draw_g.append(\"svg:path\")\n                .attr(\"class\", \"area\")\n                .attr(\"d\", path.path + path.close)\n                .call(this.fillatt.func);\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      if (axis !== \"x\") return false;\n\n      let tf1 = this.getObject();\n\n      if (tf1.fSave.length > 0) {\n         // in the case where the points have been saved, useful for example\n         // if we don't have the user's function\n         let nb_points = tf1.fNpx,\n             xmin = tf1.fSave[nb_points + 1],\n             xmax = tf1.fSave[nb_points + 2];\n\n         return Math.abs(xmin - xmax) / nb_points < Math.abs(min - max);\n      }\n\n      // if function calculated, one always could zoom inside\n      return true;\n   }\n\n   /** @summary draw TF1 object */\n   static draw(dom, tf1, opt) {\n      let painter = new TF1Painter(dom, tf1, opt),\n          d = new DrawOptions(opt),\n          has_main = !!painter.getMainPainter(),\n          aopt = \"AXIS\";\n      d.check('SAME'); // just ignore same\n      if (d.check('X+')) { aopt += \"X+\"; painter.second_x = has_main; }\n      if (d.check('Y+')) { aopt += \"Y+\"; painter.second_y = has_main; }\n      if (d.check('RX')) aopt += \"RX\";\n      if (d.check('RY')) aopt += \"RY\";\n\n      proivdeEvalPar(tf1);\n\n      let pr = Promise.resolve(true);\n\n      if (!has_main || painter.second_x || painter.second_y)\n         pr = TH1Painter.draw(dom, painter.createDummyHisto(), aopt);\n\n      return pr.then(() => {\n         painter.addToPadPrimitives();\n         painter.redraw();\n         return painter;\n      });\n   }\n\n} // class TF1Painter\n\nexport { TF1Painter, proivdeEvalPar };\n","import { TGraphPainter as TGraphPainter2D } from '../hist2d/TGraphPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { createLineSegments, create3DLineMaterial } from '../base/base3d.mjs';\n\n\nclass TGraphPainter extends TGraphPainter2D {\n\n   /** @summary Draw TGraph points in 3D\n     * @private */\n   drawBins3D(fp, graph) {\n\n      if (!fp.mode3d || !fp.grx || !fp.gry || !fp.grz || !fp.toplevel)\n         return console.log('Frame painter missing base 3d elements');\n\n      if (fp.zoom_xmin != fp.zoom_xmax)\n        if ((this.options.pos3d < fp.zoom_xmin) || (this.options.pos3d > fp.zoom_xmax)) return;\n\n      let drawbins = this.optimizeBins(1000),\n          first = 0, last = drawbins.length-1;\n\n      if (fp.zoom_ymin != fp.zoom_ymax) {\n         while ((first < last) && (drawbins[first].x < fp.zoom_ymin)) first++;\n         while ((first < last) && (drawbins[last].x > fp.zoom_ymax)) last--;\n      }\n\n      if (first == last) return;\n\n      let pnts = [], grx = fp.grx(this.options.pos3d),\n          p0 = drawbins[first];\n\n      for (let n = first + 1; n <= last; ++n) {\n         let p1 = drawbins[n];\n         pnts.push(grx, fp.gry(p0.x), fp.grz(p0.y),\n                   grx, fp.gry(p1.x), fp.grz(p1.y));\n         p0 = p1;\n      }\n\n      let lines = createLineSegments(pnts, create3DLineMaterial(this, graph));\n\n      fp.toplevel.add(lines);\n\n      fp.render3D(100);\n   }\n\n   /** @summary Draw axis histogram\n     * @private */\n   drawAxisHisto() {\n      let histo = this.createHistogram();\n      return TH1Painter.draw(this.getDom(), histo, this.options.Axis);\n   }\n\n   static draw(dom, graph, opt) {\n      return TGraphPainter._drawGraph(new TGraphPainter(dom, graph), opt);\n   }\n\n} // class TGraphPainter\n\nexport { TGraphPainter };\n"]}