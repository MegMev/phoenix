{"version":3,"file":"471.0a8995459e552787.js","mappings":"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","names":["ObjectPainter","updateObject","obj","this","matchObjectType","assignObject","redraw","getObject","func","getAxisToSvgFunc","fOper","oper","npoints","n","indx","attr","lastpath","lastkind","d","arr","split","check_attributes","kind","draw_g","append","call","fillatt","lineatt","style","markeratt","read_attr","str","names","lastp","_typename","k","length","p","indexOf","parseInt","slice","undefined","process","createAttLine","force","createAttFill","createAttMarker","fTextSize","x1","x","fBuf","y1","y","x2","y2","resetPos","create","height","getPadPainter","getPadHeight","angle","fTextAngle","txt","group","Math","floor","startTextDrawing","fTextFont","res","String","fromCharCode","drawText","align","fTextAlign","rotate","text","color","getColor","fTextColor","latex","finishTextDrawing","then","console","log","Promise","resolve","createG","dom","painter","TWebPaintingPainter","addToPadPrimitives"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TWebPaintingPainter.mjs"],"sourcesContent":["import { getColor } from '../base/colors.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\n\n\n/** @summary Draw direct TVirtualX commands into SVG\n  * @private */\n\nclass TWebPaintingPainter extends ObjectPainter {\n\n   updateObject(obj) {\n      if (!this.matchObjectType(obj)) return false;\n      this.assignObject(obj);\n      return true;\n   }\n\n   redraw() {\n\n      const obj = this.getObject(), func = this.getAxisToSvgFunc();\n\n      if (!obj?.fOper || !func) return;\n\n      let indx = 0, attr = {}, lastpath = null, lastkind = \"none\", d = \"\",\n          oper, npoints, n, arr = obj.fOper.split(\";\");\n\n      const check_attributes = kind => {\n         if (kind == lastkind) return;\n\n         if (lastpath) {\n            lastpath.attr(\"d\", d); // flush previous\n            d = \"\"; lastpath = null; lastkind = \"none\";\n         }\n\n         if (!kind) return;\n\n         lastkind = kind;\n         lastpath = this.draw_g.append(\"svg:path\");\n         switch (kind) {\n            case \"f\": lastpath.call(this.fillatt.func); break;\n            case \"l\": lastpath.call(this.lineatt.func).style('fill', 'none'); break;\n            case \"m\": lastpath.call(this.markeratt.func); break;\n         }\n      }, read_attr = (str, names) => {\n         let lastp = 0, obj = { _typename: \"any\" };\n         for (let k = 0; k < names.length; ++k) {\n            let p = str.indexOf(\":\", lastp+1);\n            obj[names[k]] = parseInt(str.slice(lastp+1, (p > lastp) ? p : undefined));\n            lastp = p;\n         }\n         return obj;\n      }, process = k => {\n         while (++k < arr.length) {\n            oper = arr[k][0];\n            switch (oper) {\n               case \"z\":\n                  this.createAttLine({ attr: read_attr(arr[k], [\"fLineColor\", \"fLineStyle\", \"fLineWidth\"]), force: true });\n                  check_attributes();\n                  continue;\n               case \"y\":\n                  this.createAttFill({ attr: read_attr(arr[k], [\"fFillColor\", \"fFillStyle\"]), force: true });\n                  check_attributes();\n                  continue;\n               case \"x\":\n                  this.createAttMarker({ attr: read_attr(arr[k], [\"fMarkerColor\", \"fMarkerStyle\", \"fMarkerSize\"]), force: true });\n                  check_attributes();\n                  continue;\n               case \"o\":\n                  attr = read_attr(arr[k], [\"fTextColor\", \"fTextFont\", \"fTextSize\", \"fTextAlign\", \"fTextAngle\"]);\n                  if (attr.fTextSize < 0) attr.fTextSize *= -0.001;\n                  check_attributes();\n                  continue;\n               case \"r\":\n               case \"b\": {\n\n                  check_attributes((oper == \"b\") ? \"f\" : \"l\");\n\n                  let x1 = func.x(obj.fBuf[indx++]),\n                      y1 = func.y(obj.fBuf[indx++]),\n                      x2 = func.x(obj.fBuf[indx++]),\n                      y2 = func.y(obj.fBuf[indx++]);\n\n                  d += `M${x1},${y1}h${x2-x1}v${y2-y1}h${x1-x2}z`;\n\n                  continue;\n               }\n               case \"l\":\n               case \"f\": {\n\n                  check_attributes(oper);\n\n                  npoints = parseInt(arr[k].slice(1));\n\n                  for (n = 0; n < npoints; ++n)\n                     d += ((n > 0) ? \"L\" : \"M\") +\n                           func.x(obj.fBuf[indx++]) + \",\" + func.y(obj.fBuf[indx++]);\n\n                  if (oper == \"f\") d+=\"Z\";\n\n                  continue;\n               }\n\n               case \"m\": {\n\n                  check_attributes(oper);\n\n                  npoints = parseInt(arr[k].slice(1));\n\n                  this.markeratt.resetPos();\n                  for (n = 0; n < npoints; ++n)\n                     d += this.markeratt.create(func.x(obj.fBuf[indx++]), func.y(obj.fBuf[indx++]));\n\n                  continue;\n               }\n\n               case \"h\":\n               case \"t\": {\n                  if (attr.fTextSize) {\n\n                     check_attributes();\n\n                     let height = (attr.fTextSize > 1) ? attr.fTextSize : this.getPadPainter().getPadHeight() * attr.fTextSize,\n                         angle = attr.fTextAngle,\n                         txt = arr[k].slice(1),\n                         group = this.draw_g.append(\"svg:g\");\n\n                     if (angle >= 360) angle -= Math.floor(angle/360) * 360;\n\n                     this.startTextDrawing(attr.fTextFont, height, group);\n\n                     if (oper == \"h\") {\n                        let res = \"\";\n                        for (n = 0; n < txt.length; n += 2)\n                           res += String.fromCharCode(parseInt(txt.slice(n,n+2), 16));\n                        txt = res;\n                     }\n\n                     // todo - correct support of angle\n                     this.drawText({ align: attr.fTextAlign,\n                                     x: func.x(obj.fBuf[indx++]),\n                                     y: func.y(obj.fBuf[indx++]),\n                                     rotate: -angle,\n                                     text: txt,\n                                     color: getColor(attr.fTextColor),\n                                     latex: 0, draw_g: group });\n\n                     return this.finishTextDrawing(group).then(() => process(k));\n                  }\n                  continue;\n               }\n\n               default:\n                  console.log('unsupported operation ' + oper);\n            }\n         };\n\n         return Promise.resolve(true);\n      }\n\n      this.createG();\n\n      return process(-1).then(() => { check_attributes(); return this; });\n   }\n\n   static draw(dom, obj) {\n      let painter = new TWebPaintingPainter(dom, obj);\n      painter.addToPadPrimitives();\n      return painter.redraw();\n   }\n\n} // class TWebPaintingPainter\n\nexport { TWebPaintingPainter };\n"]}