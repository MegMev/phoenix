{"version":3,"file":"727.ae0d068b11d3e495.js","mappings":"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","names":["ObjectPainter","updateObject","obj","opt","spline","this","getObject","_typename","Object","assign","undefined","decodeOptions","eval","knot","x","dx","fX","fY","fB","fC","fD","fE","fF","findX","klow","khig","fNp","fXmin","fXmax","fKstep","Math","round","fDelta","t","fPoly","max","khalf","createDummyHisto","xmin","xmax","ymin","ymax","forEach","min","gStyle","histo","create","fName","fTitle","fXaxis","fYaxis","processTooltipEvent","pnt","xx","yy","cleanup","main","getFramePainter","funcs","getGrFuncs","options","second_x","second_y","indx","revertAxis","fN","abs","grx","knot_size","draw_g","select","remove","gbin","radius","lineatt","width","empty","append","attr","style","call","func","res","name","title","y","gry","color1","color","lines","exact","changed","property","menu","menu_dist","sqrt","getObjectHint","length","push","axisAsText","floatToString","redraw","pmain","w","getFrameWidth","h","getFrameHeight","createG","createAttLine","Line","Curve","npx","fNpx","scale_xmin","scale_xmax","bins","logx","log","n","exp","h0","hmin","path","buildSvgPath","Mark","createAttMarker","markeratt","resetPos","getFullSize","canZoomInside","axis","d","DrawOptions","has_main","getMainPainter","Same","check","Hopt","storeDrawOpt","dom","painter","TSplinePainter","promise","Promise","resolve","no_main","console","warn","TH1Painter","then","addToPadPrimitives"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TSplinePainter.mjs"],"sourcesContent":["import { gStyle, create } from '../core.mjs';\nimport { DrawOptions, floatToString, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist/TH1Painter.mjs';\n\n\n/**\n * @summary Painter for TSpline objects.\n *\n * @private\n */\n\nclass TSplinePainter extends ObjectPainter {\n\n   /** @summary Update TSpline object\n     * @private */\n   updateObject(obj, opt) {\n      let spline = this.getObject();\n\n      if (spline._typename != obj._typename) return false;\n\n      if (spline !== obj) Object.assign(spline, obj);\n\n      if (opt !== undefined) this.decodeOptions(opt);\n\n      return true;\n   }\n\n   /** @summary Evaluate spline at given position\n     * @private */\n   eval(knot, x) {\n      let dx = x - knot.fX;\n\n      if (knot._typename == \"TSplinePoly3\")\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*knot.fD));\n\n      if (knot._typename == \"TSplinePoly5\")\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*(knot.fD + dx*(knot.fE + dx*knot.fF))));\n\n      return knot.fY + dx;\n   }\n\n   /** @summary Find idex for x value\n     * @private */\n   findX(x) {\n      let spline = this.getObject(),\n          klow = 0, khig = spline.fNp - 1;\n\n      if (x <= spline.fXmin) return 0;\n      if (x >= spline.fXmax) return khig;\n\n      if(spline.fKstep) {\n         // Equidistant knots, use histogramming\n         klow = Math.round((x - spline.fXmin)/spline.fDelta);\n         // Correction for rounding errors\n         if (x < spline.fPoly[klow].fX) {\n            klow = Math.max(klow-1,0);\n         } else if (klow < khig) {\n            if (x > spline.fPoly[klow+1].fX) ++klow;\n         }\n      } else {\n         // Non equidistant knots, binary search\n         while(khig-klow>1) {\n            let khalf = Math.round((klow+khig)/2);\n            if(x > spline.fPoly[khalf].fX) klow = khalf;\n                                      else khig = khalf;\n         }\n      }\n      return klow;\n   }\n\n   /** @summary Create histogram for axes drawing\n     * @private */\n   createDummyHisto() {\n\n      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n          spline = this.getObject();\n\n      if (spline?.fPoly) {\n\n         xmin = xmax = spline.fPoly[0].fX;\n         ymin = ymax = spline.fPoly[0].fY;\n\n         spline.fPoly.forEach(knot => {\n            xmin = Math.min(knot.fX, xmin);\n            xmax = Math.max(knot.fX, xmax);\n            ymin = Math.min(knot.fY, ymin);\n            ymax = Math.max(knot.fY, ymax);\n         });\n\n         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);\n         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);\n      }\n\n      let histo = create(\"TH1I\");\n\n      histo.fName = spline.fName + \"_hist\";\n      histo.fTitle = spline.fTitle;\n\n      histo.fXaxis.fXmin = xmin;\n      histo.fXaxis.fXmax = xmax;\n      histo.fYaxis.fXmin = ymin;\n      histo.fYaxis.fXmax = ymax;\n\n      return histo;\n   }\n\n   /** @summary Process tooltip event\n     * @private */\n   processTooltipEvent(pnt) {\n\n      let cleanup = false,\n          spline = this.getObject(),\n          main = this.getFramePainter(),\n          funcs = main?.getGrFuncs(this.options.second_x, this.options.second_y),\n          xx, yy, knot = null, indx = 0;\n\n      if ((pnt === null) || !spline || !funcs) {\n         cleanup = true;\n      } else {\n         xx = funcs.revertAxis(\"x\", pnt.x);\n         indx = this.findX(xx);\n         knot = spline.fPoly[indx];\n         yy = this.eval(knot, xx);\n\n         if ((indx < spline.fN-1) && (Math.abs(spline.fPoly[indx+1].fX-xx) < Math.abs(xx-knot.fX))) knot = spline.fPoly[++indx];\n\n         if (Math.abs(funcs.grx(knot.fX) - pnt.x) < 0.5*this.knot_size) {\n            xx = knot.fX; yy = knot.fY;\n         } else {\n            knot = null;\n            if ((xx < spline.fXmin) || (xx > spline.fXmax)) cleanup = true;\n         }\n      }\n\n      if (cleanup) {\n         if (this.draw_g)\n            this.draw_g.select(\".tooltip_bin\").remove();\n         return null;\n      }\n\n      let gbin = this.draw_g.select(\".tooltip_bin\"),\n          radius = this.lineatt.width + 3;\n\n      if (gbin.empty())\n         gbin = this.draw_g.append(\"svg:circle\")\n                           .attr(\"class\", \"tooltip_bin\")\n                           .style(\"pointer-events\",\"none\")\n                           .attr(\"r\", radius)\n                           .style(\"fill\", \"none\")\n                           .call(this.lineatt.func);\n\n      let res = { name: this.getObject().fName,\n                  title: this.getObject().fTitle,\n                  x: funcs.grx(xx),\n                  y: funcs.gry(yy),\n                  color1: this.lineatt.color,\n                  lines: [],\n                  exact: (knot !== null) || (Math.abs(funcs.gry(yy) - pnt.y) < radius) };\n\n      res.changed = gbin.property(\"current_xx\") !== xx;\n      res.menu = res.exact;\n      res.menu_dist = Math.sqrt((res.x-pnt.x)**2 + (res.y-pnt.y)**2);\n\n      if (res.changed)\n         gbin.attr(\"cx\", Math.round(res.x))\n             .attr(\"cy\", Math.round(res.y))\n             .property(\"current_xx\", xx);\n\n      let name = this.getObjectHint();\n      if (name.length > 0) res.lines.push(name);\n      res.lines.push(\"x = \" + funcs.axisAsText(\"x\", xx));\n      res.lines.push(\"y = \" + funcs.axisAsText(\"y\", yy));\n      if (knot !== null) {\n         res.lines.push(\"knot = \" + indx);\n         res.lines.push(\"B = \" + floatToString(knot.fB, gStyle.fStatFormat));\n         res.lines.push(\"C = \" + floatToString(knot.fC, gStyle.fStatFormat));\n         res.lines.push(\"D = \" + floatToString(knot.fD, gStyle.fStatFormat));\n         if ((knot.fE !== undefined) && (knot.fF !== undefined)) {\n            res.lines.push(\"E = \" + floatToString(knot.fE, gStyle.fStatFormat));\n            res.lines.push(\"F = \" + floatToString(knot.fF, gStyle.fStatFormat));\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Redraw object\n     * @private */\n   redraw() {\n\n      let spline = this.getObject(),\n          pmain = this.getFramePainter(),\n          funcs = pmain?.getGrFuncs(this.options.second_x, this.options.second_y),\n          w = pmain.getFrameWidth(),\n          h = pmain.getFrameHeight();\n\n      this.createG(true);\n\n      this.knot_size = 5; // used in tooltip handling\n\n      this.createAttLine({ attr: spline });\n\n      if (this.options.Line || this.options.Curve) {\n\n         let npx = Math.max(10, spline.fNpx),\n             xmin = Math.max(pmain.scale_xmin, spline.fXmin),\n             xmax = Math.min(pmain.scale_xmax, spline.fXmax),\n             indx = this.findX(xmin),\n             bins = []; // index of current knot\n\n         if (pmain.logx) {\n            xmin = Math.log(xmin);\n            xmax = Math.log(xmax);\n         }\n\n         for (let n = 0; n < npx; ++n) {\n            let xx = xmin + (xmax-xmin)/npx*(n-1);\n            if (pmain.logx) xx = Math.exp(xx);\n\n            while ((indx < spline.fNp-1) && (xx > spline.fPoly[indx+1].fX)) ++indx;\n\n            let yy = this.eval(spline.fPoly[indx], xx);\n\n            bins.push({ x: xx, y: yy, grx: funcs.grx(xx), gry: funcs.gry(yy) });\n         }\n\n         let h0 = h;  // use maximal frame height for filling\n         if ((pmain.hmin !== undefined) && (pmain.hmin >= 0)) {\n            h0 = Math.round(funcs.gry(0));\n            if ((h0 > h) || (h0 < 0)) h0 = h;\n         }\n\n         let path = buildSvgPath(\"bezier\", bins, h0, 2);\n\n         this.draw_g.append(\"svg:path\")\n             .attr(\"class\", \"line\")\n             .attr(\"d\", path.path)\n             .style(\"fill\", \"none\")\n             .call(this.lineatt.func);\n      }\n\n      if (this.options.Mark) {\n\n         // for tooltips use markers only if nodes where not created\n         let path = \"\";\n\n         this.createAttMarker({ attr: spline });\n\n         this.markeratt.resetPos();\n\n         this.knot_size = this.markeratt.getFullSize();\n\n         for (let n=0; n<spline.fPoly.length; n++) {\n            let knot = spline.fPoly[n],\n                grx = funcs.grx(knot.fX);\n            if ((grx > -this.knot_size) && (grx < w + this.knot_size)) {\n               let gry = funcs.gry(knot.fY);\n               if ((gry > -this.knot_size) && (gry < h + this.knot_size)) {\n                  path += this.markeratt.create(grx, gry);\n               }\n            }\n         }\n\n         if (path)\n            this.draw_g.append(\"svg:path\")\n                       .attr(\"d\", path)\n                       .call(this.markeratt.func);\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis/*,min,max*/) {\n      if (axis!==\"x\") return false;\n\n      let spline = this.getObject();\n      if (!spline) return false;\n\n      // if function calculated, one always could zoom inside\n      return true;\n   }\n\n   /** @summary Decode options for TSpline drawing */\n   decodeOptions(opt) {\n      let d = new DrawOptions(opt);\n\n      if (!this.options) this.options = {};\n\n      let has_main = !!this.getMainPainter();\n\n      Object.assign(this.options, {\n         Same: d.check('SAME'),\n         Line: d.check('L'),\n         Curve: d.check('C'),\n         Mark: d.check('P'),\n         Hopt: \"AXIS\",\n         second_x: false,\n         second_y: false\n      });\n\n      if (!this.options.Line && !this.options.Curve && !this.options.Mark)\n         this.options.Curve = true;\n\n      if (d.check(\"X+\")) { this.options.Hopt += \"X+\"; this.options.second_x = has_main; }\n      if (d.check(\"Y+\")) { this.options.Hopt += \"Y+\"; this.options.second_y = has_main; }\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw TSpline */\n   static draw(dom, spline, opt) {\n      let painter = new TSplinePainter(dom, spline);\n      painter.decodeOptions(opt);\n\n      let promise = Promise.resolve(), no_main = !painter.getMainPainter();\n      if (no_main || painter.options.second_x || painter.options.second_y) {\n         if (painter.options.Same && no_main) {\n            console.warn('TSpline painter requires histogram to be drawn');\n            return null;\n         }\n         let histo = painter.createDummyHisto();\n         promise = TH1Painter.draw(dom, histo, painter.options.Hopt);\n      }\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         painter.redraw();\n         return painter;\n      });\n   }\n\n} // class TSplinePainter\n\nexport { TSplinePainter }\n"]}