{"version":3,"file":"18.75e4ab872f8967a6.js","mappings":"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","names":["RHistPainter","constructor","dom","histo","super","this","wheel_zoomy","scanContent","when_axis_changed","getHisto","nbinsx","extractAxesProperties","hmin","hmin_nz","hmax","hsum","isDisplayItem","fContMin","fContMinPos","fContMax","left","getSelectIndex","right","scan_xleft","scan_xright","value","err","first","i","getBinContent","Math","min","max","stat_entries","ymin_nz","draw_content","abs","ymin","ymax","e","dy","countStat","cond","xaxis","getAxis","stat_sumw","stat_sumwx","stat_sumwx2","xx","w","xmax","wmax","fp","getFramePainter","res","name","meanx","meany","rmsx","rmsy","integral","entries","GetBinCoord","isAxisZoomed","fTsumw","fTsumwx","fTsumwx2","sqrt","fillStatistic","stat","dostat","data","print_name","print_entries","floor","print_mean","print_rms","print_under","print_over","print_integral","print_skew","print_kurt","clearStat","addText","format","drawBars","handle","funcs","width","height","createG","x1","x2","grx1","grx2","y","gry1","gry2","i1","i2","di","stepi","pmain","bars","barsl","barsr","swap_xy","Number","isFinite","options","BaseLine","scale_ymin","round","gry","logx","grx","logy","BarOffset","BarWidth","n","BarStyle","fillatt","empty","setSolidColor","length","draw_g","append","attr","call","func","style","d3_rgb","color","brighter","formatHex","darker","Promise","resolve","drawFilledErrors","x","yerr","bins1","bins2","getBinError","push","unshift","kind","ErrorKind","path1","buildSvgPath","path2","path","draw1DBins","rect","getFrameRect","removeG","createHistDrawAttributes","prepareDraw","extra","only_indexes","getGrFuncs","second_x","second_y","Bar","drawHistBins","startx","currx","curry","curry_min","curry_max","prevy","prevx","bestimin","bestimax","my","yerr1","yerr2","bincont","binerr","mx1","mx2","midx","text_font","want_tooltip","isBatchMode","settings","lastbin","exclude_zero","Zero","show_errors","Error","show_markers","Mark","show_line","Line","show_text","Text","path_fill","path_err","path_marker","path_line","hints_err","endx","endy","dend","v7EvalAttr","r","createv7AttMarker","markeratt","size","resetPos","v7EvalFont","align","angle","TextKind","space","setAngle","setSize","startTextDrawing","use_minmax","lw","lineatt","gStyle","draw_markers","draw_bin","besti","lbl","toString","floatToString","drawText","text","latex","create","edx","errorX","mmx1","u","s","ht","c","B","close_path","fill_for_interactive","Hist","h0","gry0","Fill","finishTextDrawing","getBinTooltips","bin","tips","getObjectHint","stepx","cont","xlbl","getAxisBinTip","axisAsText","toPrecision","$baseh","processTooltipEvent","pnt","Mode3D","select","remove","show_rect","midy","getFrameWidth","getFrameHeight","findbin","gapx","l","yy","pnt_x","pnt_y","m","GetBinGrX","C","best","dist","GetBinGrY","d","touch","nproc","msize","getFullSize","dx","o","ttrect","title","fTitle","exact","color1","color2","getFillColorAlt","lines","disabled","changed","property","menu","menu_dist","radius","user_info","obj","fillHistContextMenu","add","autoZoom","opts","getSupportedDrawOptions","addDrawMenu","arg","showInspector","decodeOptions","need_fillcol","change","interactiveRedraw","indx","zoom","canZoomInside","axis","FindBin","callDrawFunc","reason","main","mode3d","isMainPainter","draw3D","draw2D","clear3DScene","drawFrameAxes","then","drawingBins","addInteractivity","console","log","redraw","painter","opt","ensureRCanvas","setAsMainPainter","Lego","Surf","TextAngle","AutoColor","DrawOptions","check","Render3D","constants","part","toLowerCase","sub","has_main","getMainPainter","RH1Painter","_draw","RH1Painter2D","is_main","zmult","pr","resize3D","render3D","deleteAttr","assignFrame3DMethods","create3DScene","setAxesRanges","xmin","set3DOptions","drawXYZ","toplevel","RAxisPainter","use_y_for_z","ndim","draw","v7","drawBinsLego","updatePaletteDraw","addKeysHandler"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist2d/RH1Painter.mjs","../node_modules/jsroot/modules/hist/RH1Painter.mjs"],"sourcesContent":["import { gStyle, settings, constants, isBatchMode } from '../core.mjs';\nimport { rgb as d3_rgb } from '../d3.mjs';\nimport { floatToString, DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { RHistPainter } from './RHistPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\n\n/**\n * @summary Painter for RH1 classes\n *\n * @private\n */\n\nclass RH1Painter extends RHistPainter {\n\n   /** @summary Constructor\n     * @param {object|string} dom - DOM element or id\n     * @param {object} histo - histogram object */\n   constructor(dom, histo) {\n      super(dom, histo);\n      this.wheel_zoomy = false;\n   }\n\n   /** @summary Scan content */\n   scanContent(when_axis_changed) {\n      // if when_axis_changed === true specified, content will be scanned after axis zoom changed\n\n      let histo = this.getHisto();\n      if (!histo) return;\n\n      if (!this.nbinsx && when_axis_changed) when_axis_changed = false;\n\n      if (!when_axis_changed)\n         this.extractAxesProperties(1);\n\n      let hmin = 0, hmin_nz = 0, hmax = 0, hsum = 0;\n\n      if (this.isDisplayItem()) {\n         // take min/max values from the display item\n         hmin = histo.fContMin;\n         hmin_nz = histo.fContMinPos;\n         hmax = histo.fContMax;\n         hsum = hmax;\n      } else {\n\n         let left = this.getSelectIndex(\"x\", \"left\"),\n             right = this.getSelectIndex(\"x\", \"right\");\n\n         if (when_axis_changed) {\n            if ((left === this.scan_xleft) && (right === this.scan_xright)) return;\n         }\n\n         this.scan_xleft = left;\n         this.scan_xright = right;\n\n         let first = true, value, err;\n\n         for (let i = 0; i < this.nbinsx; ++i) {\n            value = histo.getBinContent(i+1);\n            hsum += value;\n\n            if ((i<left) || (i>=right)) continue;\n\n            if (value > 0)\n               if ((hmin_nz == 0) || (value<hmin_nz)) hmin_nz = value;\n            if (first) {\n               hmin = hmax = value;\n               first = false;\n            }\n\n            err =  0;\n\n            hmin = Math.min(hmin, value - err);\n            hmax = Math.max(hmax, value + err);\n         }\n      }\n\n      this.stat_entries = hsum;\n\n      this.hmin = hmin;\n      this.hmax = hmax;\n\n      this.ymin_nz = hmin_nz; // value can be used to show optimal log scale\n\n      if ((this.nbinsx == 0) || ((Math.abs(hmin) < 1e-300 && Math.abs(hmax) < 1e-300))) {\n         this.draw_content = false;\n      } else {\n         this.draw_content = true;\n      }\n\n      if (this.draw_content) {\n         if (hmin >= hmax) {\n            if (hmin == 0) { this.ymin = 0; this.ymax = 1; }\n            else if (hmin < 0) { this.ymin = 2 * hmin; this.ymax = 0; }\n            else { this.ymin = 0; this.ymax = hmin * 2; }\n         } else {\n            let dy = (hmax - hmin) * 0.05;\n            this.ymin = hmin - dy;\n            if ((this.ymin < 0) && (hmin >= 0)) this.ymin = 0;\n            this.ymax = hmax + dy;\n         }\n      }\n   }\n\n   /** @summary Count statistic */\n   countStat(cond) {\n      let histo = this.getHisto(), xaxis = this.getAxis(\"x\"),\n          left = this.getSelectIndex(\"x\", \"left\"),\n          right = this.getSelectIndex(\"x\", \"right\"),\n          stat_sumw = 0, stat_sumwx = 0, stat_sumwx2 = 0, stat_sumwy = 0, stat_sumwy2 = 0,\n          i, xx = 0, w = 0, xmax = null, wmax = null,\n          fp = this.getFramePainter(),\n          res = { name: \"histo\", meanx: 0, meany: 0, rmsx: 0, rmsy: 0, integral: 0, entries: this.stat_entries, xmax: 0, wmax: 0 };\n\n      for (i = left; i < right; ++i) {\n         xx = xaxis.GetBinCoord(i+0.5);\n\n         if (cond && !cond(xx)) continue;\n\n         w = histo.getBinContent(i + 1);\n\n         if ((xmax === null) || (w > wmax)) { xmax = xx; wmax = w; }\n\n         stat_sumw += w;\n         stat_sumwx += w * xx;\n         stat_sumwx2 += w * xx**2;\n      }\n\n      // when no range selection done, use original statistic from histogram\n      if (!fp.isAxisZoomed(\"x\") && histo.fTsumw) {\n         stat_sumw = histo.fTsumw;\n         stat_sumwx = histo.fTsumwx;\n         stat_sumwx2 = histo.fTsumwx2;\n      }\n\n      res.integral = stat_sumw;\n\n      if (stat_sumw > 0) {\n         res.meanx = stat_sumwx / stat_sumw;\n         res.meany = stat_sumwy / stat_sumw;\n         res.rmsx = Math.sqrt(Math.abs(stat_sumwx2 / stat_sumw - res.meanx**2));\n         res.rmsy = Math.sqrt(Math.abs(stat_sumwy2 / stat_sumw - res.meany**2));\n      }\n\n      if (xmax !== null) {\n         res.xmax = xmax;\n         res.wmax = wmax;\n      }\n\n      return res;\n   }\n\n   /** @summary Fill statistic */\n   fillStatistic(stat, dostat/*, dofit*/) {\n\n      let data = this.countStat(),\n          print_name = dostat % 10,\n          print_entries = Math.floor(dostat / 10) % 10,\n          print_mean = Math.floor(dostat / 100) % 10,\n          print_rms = Math.floor(dostat / 1000) % 10,\n          print_under = Math.floor(dostat / 10000) % 10,\n          print_over = Math.floor(dostat / 100000) % 10,\n          print_integral = Math.floor(dostat / 1000000) % 10,\n          print_skew = Math.floor(dostat / 10000000) % 10,\n          print_kurt = Math.floor(dostat / 100000000) % 10;\n\n      // make empty at the beginning\n      stat.clearStat();\n\n      if (print_name > 0)\n         stat.addText(data.name);\n\n      if (print_entries > 0)\n         stat.addText(\"Entries = \" + stat.format(data.entries,\"entries\"));\n\n      if (print_mean > 0)\n         stat.addText(\"Mean = \" + stat.format(data.meanx));\n\n      if (print_rms > 0)\n         stat.addText(\"Std Dev = \" + stat.format(data.rmsx));\n\n      if (print_under > 0)\n         stat.addText(\"Underflow = \" + stat.format(histo.getBinContent(0), \"entries\"));\n\n      if (print_over > 0)\n         stat.addText(\"Overflow = \" + stat.format(histo.getBinContent(this.nbinsx+1), \"entries\"));\n\n      if (print_integral > 0)\n         stat.addText(\"Integral = \" + stat.format(data.integral,\"entries\"));\n\n      if (print_skew > 0)\n         stat.addText(\"Skew = <not avail>\");\n\n      if (print_kurt > 0)\n         stat.addText(\"Kurt = <not avail>\");\n\n      return true;\n   }\n\n   /** @summary Draw histogram as bars */\n   drawBars(handle, funcs, width, height) {\n\n      this.createG(true);\n\n      let left = handle.i1, right = handle.i2, di = handle.stepi,\n          pmain = this.getFramePainter(),\n          histo = this.getHisto(), xaxis = this.getAxis(\"x\"),\n          i, x1, x2, grx1, grx2, y, gry1, gry2, w,\n          bars = \"\", barsl = \"\", barsr = \"\";\n\n      gry2 = pmain.swap_xy ? 0 : height;\n      if (Number.isFinite(this.options.BaseLine))\n         if (this.options.BaseLine >= funcs.scale_ymin)\n            gry2 = Math.round(funcs.gry(this.options.BaseLine));\n\n      for (i = left; i < right; i += di) {\n         x1 = xaxis.GetBinCoord(i);\n         x2 = xaxis.GetBinCoord(i+di);\n\n         if (funcs.logx && (x2 <= 0)) continue;\n\n         grx1 = Math.round(funcs.grx(x1));\n         grx2 = Math.round(funcs.grx(x2));\n\n         y = histo.getBinContent(i+1);\n         if (funcs.logy && (y < funcs.scale_ymin)) continue;\n         gry1 = Math.round(funcs.gry(y));\n\n         w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         w = Math.round(this.options.BarWidth*w);\n\n         if (pmain.swap_xy)\n            bars += \"M\"+gry2+\",\"+grx1 + \"h\"+(gry1-gry2) + \"v\"+w + \"h\"+(gry2-gry1) + \"z\";\n         else\n            bars += \"M\"+grx1+\",\"+gry1 + \"h\"+w + \"v\"+(gry2-gry1) + \"h\"+(-w)+ \"z\";\n\n         if (this.options.BarStyle > 0) {\n            grx2 = grx1 + w;\n            w = Math.round(w / 10);\n            if (pmain.swap_xy) {\n               barsl += \"M\"+gry2+\",\"+grx1 + \"h\"+(gry1-gry2) + \"v\" + w + \"h\"+(gry2-gry1) + \"z\";\n               barsr += \"M\"+gry2+\",\"+grx2 + \"h\"+(gry1-gry2) + \"v\" + (-w) + \"h\"+(gry2-gry1) + \"z\";\n            } else {\n               barsl += \"M\"+grx1+\",\"+gry1 + \"h\"+w + \"v\"+(gry2-gry1) + \"h\"+(-w)+ \"z\";\n               barsr += \"M\"+grx2+\",\"+gry1 + \"h\"+(-w) + \"v\"+(gry2-gry1) + \"h\"+w + \"z\";\n            }\n         }\n      }\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor(\"blue\");\n\n      if (bars.length > 0)\n         this.draw_g.append(\"svg:path\")\n                    .attr(\"d\", bars)\n                    .call(this.fillatt.func);\n\n      if (barsl.length > 0)\n         this.draw_g.append(\"svg:path\")\n               .attr(\"d\", barsl)\n               .call(this.fillatt.func)\n               .style(\"fill\", d3_rgb(this.fillatt.color).brighter(0.5).formatHex());\n\n      if (barsr.length > 0)\n         this.draw_g.append(\"svg:path\")\n               .attr(\"d\", barsr)\n               .call(this.fillatt.func)\n               .style(\"fill\", d3_rgb(this.fillatt.color).darker(0.5).formatHex());\n\n       return Promise.resolve(true);\n   }\n\n   /** @summary Draw histogram as filled errors */\n   drawFilledErrors(handle, funcs /*, width, height*/) {\n      this.createG(true);\n\n      let left = handle.i1, right = handle.i2, di = handle.stepi,\n          histo = this.getHisto(), xaxis = this.getAxis(\"x\"),\n          i, x, grx, y, yerr, gry1, gry2,\n          bins1 = [], bins2 = [];\n\n      for (i = left; i < right; i += di) {\n         x = xaxis.GetBinCoord(i+0.5);\n         if (funcs.logx && (x <= 0)) continue;\n         grx = Math.round(funcs.grx(x));\n\n         y = histo.getBinContent(i+1);\n         yerr = histo.getBinError(i+1);\n         if (funcs.logy && (y-yerr < funcs.scale_ymin)) continue;\n\n         gry1 = Math.round(funcs.gry(y + yerr));\n         gry2 = Math.round(funcs.gry(y - yerr));\n\n         bins1.push({grx: grx, gry: gry1});\n         bins2.unshift({grx: grx, gry: gry2});\n      }\n\n      let kind = (this.options.ErrorKind === 4) ? \"bezier\" : \"line\",\n          path1 = buildSvgPath(kind, bins1),\n          path2 = buildSvgPath(\"L\"+kind, bins2);\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor(\"blue\");\n\n      this.draw_g.append(\"svg:path\")\n                 .attr(\"d\", path1.path + path2.path + \"Z\")\n                 .call(this.fillatt.func);\n\n      return Promise.resolve(true);\n   }\n\n   /** @summary Draw 1D histogram as SVG */\n   draw1DBins() {\n\n      let pmain = this.getFramePainter(),\n          rect = pmain.getFrameRect();\n\n      if (!this.draw_content || (rect.width <= 0) || (rect.height <= 0)) {\n         this.removeG()\n         return Promise.resolve(false);\n      }\n\n      this.createHistDrawAttributes();\n\n      let handle = this.prepareDraw({ extra: 1, only_indexes: true }),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);\n\n      if (this.options.Bar)\n         return this.drawBars(handle, funcs, rect.width, rect.height);\n\n      if ((this.options.ErrorKind === 3) || (this.options.ErrorKind === 4))\n         return this.drawFilledErrors(handle, funcs, rect.width, rect.height);\n\n      return this.drawHistBins(handle, funcs, rect.width, rect.height);\n   }\n\n   /** @summary Draw histogram bins */\n   drawHistBins(handle, funcs, width, height) {\n      this.createG(true);\n\n      let options = this.options,\n          left = handle.i1,\n          right = handle.i2,\n          di = handle.stepi,\n          histo = this.getHisto(),\n          want_tooltip = !isBatchMode() && settings.Tooltip,\n          xaxis = this.getAxis(\"x\"),\n          res = \"\", lastbin = false,\n          startx, currx, curry, x, grx, y, gry, curry_min, curry_max, prevy, prevx, i, bestimin, bestimax,\n          exclude_zero = !options.Zero,\n          show_errors = options.Error,\n          show_markers = options.Mark,\n          show_line = options.Line,\n          show_text = options.Text,\n          path_fill = null, path_err = null, path_marker = null, path_line = null,\n          hints_err = null,\n          endx = \"\", endy = \"\", dend = 0, my, yerr1, yerr2, bincont, binerr, mx1, mx2, midx,\n          text_font;\n\n      if (show_errors && !show_markers && (this.v7EvalAttr(\"marker_style\",1) > 1))\n         show_markers = true;\n\n      if (options.ErrorKind === 2) {\n         if (this.fillatt.empty()) show_markers = true;\n                              else path_fill = \"\";\n      } else if (options.Error) {\n         path_err = \"\";\n         hints_err = want_tooltip ? \"\" : null;\n      }\n\n      if (show_line) path_line = \"\";\n\n      if (show_markers) {\n         // draw markers also when e2 option was specified\n         this.createv7AttMarker();\n         if (this.markeratt.size > 0) {\n            // simply use relative move from point, can optimize in the future\n            path_marker = \"\";\n            this.markeratt.resetPos();\n         } else {\n            show_markers = false;\n         }\n      }\n\n      if (show_text) {\n         text_font = this.v7EvalFont(\"text\", { size: 20, color: \"black\", align: 22 });\n\n         if (!text_font.angle && !options.TextKind) {\n             let space = width / (right - left + 1);\n             if (space < 3 * text_font.size) {\n                text_font.setAngle(270);\n                text_font.setSize(Math.round(space*0.7));\n             }\n         }\n\n         this.startTextDrawing(text_font, 'font');\n      }\n\n      // if there are too many points, exclude many vertical drawings at the same X position\n      // instead define min and max value and made min-max drawing\n      let use_minmax = ((right-left) > 3*width);\n\n      if (options.ErrorKind === 1) {\n         let lw = this.lineatt.width + gStyle.fEndErrorSize;\n         endx = \"m0,\" + lw + \"v-\" + 2*lw + \"m0,\" + lw;\n         endy = \"m\" + lw + \",0h-\" + 2*lw + \"m\" + lw + \",0\";\n         dend = Math.floor((this.lineatt.width-1)/2);\n      }\n\n      let draw_markers = show_errors || show_markers;\n\n      if (draw_markers || show_text || show_line) use_minmax = true;\n\n      let draw_bin = besti => {\n         bincont = histo.getBinContent(besti+1);\n         if (!exclude_zero || (bincont!==0)) {\n            mx1 = Math.round(funcs.grx(xaxis.GetBinCoord(besti)));\n            mx2 = Math.round(funcs.grx(xaxis.GetBinCoord(besti+di)));\n            midx = Math.round((mx1+mx2)/2);\n            my = Math.round(funcs.gry(bincont));\n            yerr1 = yerr2 = 20;\n            if (show_errors) {\n               binerr = histo.getBinError(besti+1);\n               yerr1 = Math.round(my - funcs.gry(bincont + binerr)); // up\n               yerr2 = Math.round(funcs.gry(bincont - binerr) - my); // down\n            }\n\n            if (show_text && (bincont !== 0)) {\n               let lbl = (bincont === Math.round(bincont)) ? bincont.toString() : floatToString(bincont, gStyle.fPaintTextFormat);\n\n               if (text_font.angle)\n                  this.drawText({ align: 12, x: midx, y: Math.round(my - 2 - text_font.size / 5), text: lbl, latex: 0 });\n               else\n                  this.drawText({ x: Math.round(mx1 + (mx2 - mx1) * 0.1), y: Math.round(my - 2 - text_font.size), width: Math.round((mx2 - mx1) * 0.8), height: text_font.size, text: lbl, latex: 0 });\n            }\n\n            if (show_line && (path_line !== null))\n               path_line += ((path_line.length === 0) ? \"M\" : \"L\") + midx + \",\" + my;\n\n            if (draw_markers) {\n               if ((my >= -yerr1) && (my <= height + yerr2)) {\n                  if (path_fill !== null)\n                     path_fill += \"M\" + mx1 +\",\"+(my-yerr1) +\n                                  \"h\" + (mx2-mx1) + \"v\" + (yerr1+yerr2+1) + \"h-\" + (mx2-mx1) + \"z\";\n                  if (path_marker !== null)\n                     path_marker += this.markeratt.create(midx, my);\n                  if (path_err !== null) {\n                     let edx = 5;\n                     if (this.options.errorX > 0) {\n                        edx = Math.round((mx2-mx1)*this.options.errorX);\n                        let mmx1 = midx - edx, mmx2 = midx + edx;\n                        path_err += \"M\" + (mmx1+dend) +\",\"+ my + endx + \"h\" + (mmx2-mmx1-2*dend) + endx;\n                     }\n                     path_err += \"M\" + midx +\",\" + (my-yerr1+dend) + endy + \"v\" + (yerr1+yerr2-2*dend) + endy;\n                     if (hints_err !== null)\n                        hints_err += \"M\" + (midx-edx) + \",\" + (my-yerr1) + \"h\" + (2*edx) + \"v\" + (yerr1+yerr2) + \"h\" + (-2*edx) + \"z\";\n                  }\n               }\n            }\n         }\n      };\n\n      for (i = left; i <= right; i += di) {\n\n         x = xaxis.GetBinCoord(i);\n\n         if (funcs.logx && (x <= 0)) continue;\n\n         grx = Math.round(funcs.grx(x));\n\n         lastbin = (i > right - di);\n\n         if (lastbin && (left < right)) {\n            gry = curry;\n         } else {\n            y = histo.getBinContent(i+1);\n            gry = Math.round(funcs.gry(y));\n         }\n\n         if (res.length === 0) {\n            bestimin = bestimax = i;\n            prevx = startx = currx = grx;\n            prevy = curry_min = curry_max = curry = gry;\n            res = \"M\"+currx+\",\"+curry;\n         } else\n         if (use_minmax) {\n            if ((grx === currx) && !lastbin) {\n               if (gry < curry_min) bestimax = i; else\n               if (gry > curry_max) bestimin = i;\n               curry_min = Math.min(curry_min, gry);\n               curry_max = Math.max(curry_max, gry);\n               curry = gry;\n            } else {\n\n               if (draw_markers || show_text || show_line) {\n                  if (bestimin === bestimax) { draw_bin(bestimin); } else\n                     if (bestimin < bestimax) { draw_bin(bestimin); draw_bin(bestimax); } else {\n                        draw_bin(bestimax); draw_bin(bestimin);\n                     }\n               }\n\n               // when several points as same X differs, need complete logic\n               if (!draw_markers && ((curry_min !== curry_max) || (prevy !== curry_min))) {\n\n                  if (prevx !== currx)\n                     res += \"h\"+(currx-prevx);\n\n                  if (curry === curry_min) {\n                     if (curry_max !== prevy)\n                        res += \"v\" + (curry_max - prevy);\n                     if (curry_min !== curry_max)\n                        res += \"v\" + (curry_min - curry_max);\n                  } else {\n                     if (curry_min !== prevy)\n                        res += \"v\" + (curry_min - prevy);\n                     if (curry_max !== curry_min)\n                        res += \"v\" + (curry_max - curry_min);\n                     if (curry !== curry_max)\n                       res += \"v\" + (curry - curry_max);\n                  }\n\n                  prevx = currx;\n                  prevy = curry;\n               }\n\n               if (lastbin && (prevx !== grx))\n                  res += \"h\"+(grx-prevx);\n\n               bestimin = bestimax = i;\n               curry_min = curry_max = curry = gry;\n               currx = grx;\n            }\n         } else\n         if ((gry !== curry) || lastbin) {\n            if (grx !== currx) res += \"h\"+(grx-currx);\n            if (gry !== curry) res += \"v\"+(gry-curry);\n            curry = gry;\n            currx = grx;\n         }\n      }\n\n      let close_path = \"\",\n          fill_for_interactive = !isBatchMode() && this.fillatt.empty() && options.Hist && settings.Tooltip && !draw_markers && !show_line;\n      if (!this.fillatt.empty() || fill_for_interactive) {\n         let h0 = height + 3;\n         if (fill_for_interactive) {\n            let gry0 = Math.round(funcs.gry(0));\n            if (gry0 <= 0)\n               h0 = -3;\n            else if (gry0 < height)\n               h0 = gry0;\n         }\n         close_path = `L${currx},${h0}H${startx}Z`;\n         if (res.length > 0) res += close_path;\n      }\n\n      if (draw_markers || show_line) {\n         if ((path_fill !== null) && (path_fill.length > 0))\n            this.draw_g.append(\"svg:path\")\n                       .attr(\"d\", path_fill)\n                       .call(this.fillatt.func);\n\n         if ((path_err !== null) && (path_err.length > 0))\n               this.draw_g.append(\"svg:path\")\n                   .attr(\"d\", path_err)\n                   .call(this.lineatt.func);\n\n         if ((hints_err !== null) && (hints_err.length > 0))\n               this.draw_g.append(\"svg:path\")\n                   .attr(\"d\", hints_err)\n                   .style(\"fill\", \"none\")\n                   .style(\"pointer-events\", isBatchMode() ? null : \"visibleFill\");\n\n         if ((path_line !== null) && (path_line.length > 0)) {\n            if (!this.fillatt.empty())\n               this.draw_g.append(\"svg:path\")\n                     .attr(\"d\", options.Fill ? (path_line + close_path) : res)\n                     .call(this.fillatt.func);\n\n            this.draw_g.append(\"svg:path\")\n                   .attr(\"d\", path_line)\n                   .style(\"fill\", \"none\")\n                   .call(this.lineatt.func);\n         }\n\n         if ((path_marker !== null) && (path_marker.length > 0))\n            this.draw_g.append(\"svg:path\")\n                .attr(\"d\", path_marker)\n                .call(this.markeratt.func);\n\n      } else if (res && options.Hist) {\n         this.draw_g.append(\"svg:path\")\n                    .attr(\"d\", res)\n                    .style(\"stroke-linejoin\",\"miter\")\n                    .call(this.lineatt.func)\n                    .call(this.fillatt.func);\n      }\n\n      return show_text ? this.finishTextDrawing() : Promise.resolve(true);\n   }\n\n   /** @summary Provide text information (tooltips) for histogram bin */\n   getBinTooltips(bin) {\n      let tips = [],\n          name = this.getObjectHint(),\n          pmain = this.getFramePainter(),\n          histo = this.getHisto(),\n          xaxis = this.getAxis(\"x\"),\n          di = this.isDisplayItem() ? histo.stepx : 1,\n          x1 = xaxis.GetBinCoord(bin),\n          x2 = xaxis.GetBinCoord(bin+di),\n          cont = histo.getBinContent(bin+1),\n          xlbl = this.getAxisBinTip(\"x\", bin, di);\n\n      if (name.length>0) tips.push(name);\n\n      if (this.options.Error || this.options.Mark) {\n         tips.push(\"x = \" + xlbl);\n         tips.push(\"y = \" + pmain.axisAsText(\"y\", cont));\n         if (this.options.Error) {\n            if (xlbl[0] == \"[\") tips.push(\"error x = \" + ((x2 - x1) / 2).toPrecision(4));\n            tips.push(\"error y = \" + histo.getBinError(bin + 1).toPrecision(4));\n         }\n      } else {\n         tips.push(\"bin = \" + bin);\n         tips.push(\"x = \" + xlbl);\n         if (histo['$baseh']) cont -= histo['$baseh'].getBinContent(bin+1);\n         let lbl = \"entries = \" + (di > 1 ? \"~\" : \"\");\n         if (cont === Math.round(cont))\n            tips.push(lbl + cont);\n         else\n            tips.push(lbl + floatToString(cont, gStyle.fStatFormat));\n      }\n\n      return tips;\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      if (!pnt || !this.draw_content || this.options.Mode3D || !this.draw_g) {\n         if (this.draw_g)\n            this.draw_g.select(\".tooltip_bin\").remove();\n         return null;\n      }\n\n      let pmain = this.getFramePainter(),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          width = pmain.getFrameWidth(),\n          height = pmain.getFrameHeight(),\n          histo = this.getHisto(), xaxis = this.getAxis(\"x\"),\n          findbin = null, show_rect,\n          grx1, midx, grx2, gry1, midy, gry2, gapx = 2,\n          left = this.getSelectIndex(\"x\", \"left\", -1),\n          right = this.getSelectIndex(\"x\", \"right\", 2),\n          l = left, r = right;\n\n      function GetBinGrX(i) {\n         let xx = xaxis.GetBinCoord(i);\n         return (funcs.logx && (xx<=0)) ? null : funcs.grx(xx);\n      }\n\n      function GetBinGrY(i) {\n         let yy = histo.getBinContent(i + 1);\n         if (funcs.logy && (yy < funcs.scale_ymin))\n            return funcs.swap_xy ? -1000 : 10*height;\n         return Math.round(funcs.gry(yy));\n      }\n\n      let pnt_x = funcs.swap_xy ? pnt.y : pnt.x,\n          pnt_y = funcs.swap_xy ? pnt.x : pnt.y;\n\n      while (l < r-1) {\n         let m = Math.round((l+r)*0.5),\n             xx = GetBinGrX(m);\n         if ((xx === null) || (xx < pnt_x - 0.5)) {\n            if (funcs.swap_xy) r = m; else l = m;\n         } else if (xx > pnt_x + 0.5) {\n            if (funcs.swap_xy) l = m; else r = m;\n         } else { l++; r--; }\n      }\n\n      findbin = r = l;\n      grx1 = GetBinGrX(findbin);\n\n      if (funcs.swap_xy) {\n         while ((l>left) && (GetBinGrX(l-1) < grx1 + 2)) --l;\n         while ((r<right) && (GetBinGrX(r+1) > grx1 - 2)) ++r;\n      } else {\n         while ((l>left) && (GetBinGrX(l-1) > grx1 - 2)) --l;\n         while ((r<right) && (GetBinGrX(r+1) < grx1 + 2)) ++r;\n      }\n\n      if (l < r) {\n         // many points can be assigned with the same cursor position\n         // first try point around mouse y\n         let best = height;\n         for (let m=l;m<=r;m++) {\n            let dist = Math.abs(GetBinGrY(m) - pnt_y);\n            if (dist < best) { best = dist; findbin = m; }\n         }\n\n         // if best distance still too far from mouse position, just take from between\n         if (best > height/10)\n            findbin = Math.round(l + (r-l) / height * pnt_y);\n\n         grx1 = GetBinGrX(findbin);\n      }\n\n      grx1 = Math.round(grx1);\n      grx2 = Math.round(GetBinGrX(findbin+1));\n\n      if (this.options.Bar) {\n         let w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         grx2 = grx1 + Math.round(this.options.BarWidth*w);\n      }\n\n      if (grx1 > grx2) { let d = grx1; grx1 = grx2; grx2 = d; }\n\n      midx = Math.round((grx1+grx2)/2);\n\n      midy = gry1 = gry2 = GetBinGrY(findbin);\n\n      if (this.options.Bar) {\n         show_rect = true;\n\n         gapx = 0;\n\n         gry1 = Math.round(funcs.gry(((this.options.BaseLine!==false) && (this.options.BaseLine > funcs.scale_ymin)) ? this.options.BaseLine : funcs.scale_ymin));\n\n         if (gry1 > gry2) { let d = gry1; gry1 = gry2; gry2 = d; }\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y<gry1) || (pnt_y>gry2)) findbin = null;\n\n      } else if (this.options.Error || this.options.Mark) {\n\n         show_rect = true;\n\n         let msize = 3;\n         if (this.markeratt) msize = Math.max(msize, this.markeratt.getFullSize());\n\n         if (this.options.Error) {\n            let cont = histo.getBinContent(findbin+1),\n                binerr = histo.getBinError(findbin+1);\n\n            gry1 = Math.round(funcs.gry(cont + binerr)); // up\n            gry2 = Math.round(funcs.gry(cont - binerr)); // down\n\n            let dx = (grx2-grx1)*this.options.errorX;\n            grx1 = Math.round(midx - dx);\n            grx2 = Math.round(midx + dx);\n         }\n\n         // show at least 6 pixels as tooltip rect\n         if (grx2 - grx1 < 2*msize) { grx1 = midx-msize; grx2 = midx+msize; }\n\n         gry1 = Math.min(gry1, midy - msize);\n         gry2 = Math.max(gry2, midy + msize);\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y<gry1) || (pnt_y>gry2)) findbin = null;\n\n      } else if (this.options.Line) {\n\n         show_rect = false;\n\n      } else {\n\n         // if histogram alone, use old-style with rects\n         // if there are too many points at pixel, use circle\n         show_rect = (pnt.nproc === 1) && (right-left < width);\n\n         if (show_rect) {\n            gry2 = height;\n\n            if (!this.fillatt.empty()) {\n               gry2 = Math.round(funcs.gry(0));\n               if (gry2 < 0) gry2 = 0; else if (gry2 > height) gry2 = height;\n               if (gry2 < gry1) { let d = gry1; gry1 = gry2; gry2 = d; }\n            }\n\n            // for mouse events pointer should be between y1 and y2\n            if (((pnt.y < gry1) || (pnt.y > gry2)) && !pnt.touch) findbin = null;\n         }\n      }\n\n      if (findbin!==null) {\n         // if bin on boundary found, check that x position is ok\n         if ((findbin === left) && (grx1 > pnt_x + gapx))  findbin = null; else\n         if ((findbin === right-1) && (grx2 < pnt_x - gapx)) findbin = null; else\n         // if bars option used check that bar is not match\n         if ((pnt_x < grx1 - gapx) || (pnt_x > grx2 + gapx)) findbin = null; else\n         // exclude empty bin if empty bins suppressed\n         if (!this.options.Zero && (histo.getBinContent(findbin+1)===0)) findbin = null;\n      }\n\n      let ttrect = this.draw_g.select(\".tooltip_bin\");\n\n      if ((findbin === null) || ((gry2 <= 0) || (gry1 >= height))) {\n         ttrect.remove();\n         return null;\n      }\n\n      let res = { name: \"histo\", title: histo.fTitle,\n                  x: midx, y: midy, exact: true,\n                  color1: this.lineatt ? this.lineatt.color : 'green',\n                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',\n                  lines: this.getBinTooltips(findbin) };\n\n      if (pnt.disabled) {\n         // case when tooltip should not highlight bin\n\n         ttrect.remove();\n         res.changed = true;\n      } else if (show_rect) {\n\n         if (ttrect.empty())\n            ttrect = this.draw_g.append(\"svg:rect\")\n                                .attr(\"class\",\"tooltip_bin h1bin\")\n                                .style(\"pointer-events\",\"none\");\n\n         res.changed = ttrect.property(\"current_bin\") !== findbin;\n\n         if (res.changed)\n            ttrect.attr(\"x\", pmain.swap_xy ? gry1 : grx1)\n                  .attr(\"width\", pmain.swap_xy ? gry2-gry1 : grx2-grx1)\n                  .attr(\"y\", pmain.swap_xy ? grx1 : gry1)\n                  .attr(\"height\", pmain.swap_xy ? grx2-grx1 : gry2-gry1)\n                  .style(\"opacity\", \"0.3\")\n                  .property(\"current_bin\", findbin);\n\n         res.exact = (Math.abs(midy - pnt_y) <= 5) || ((pnt_y>=gry1) && (pnt_y<=gry2));\n\n         res.menu = res.exact; // one could show context menu\n         // distance to middle point, use to decide which menu to activate\n         res.menu_dist = Math.sqrt((midx-pnt_x)**2 + (midy-pnt_y)**2);\n\n      } else {\n         let radius = this.lineatt.width + 3;\n\n         if (ttrect.empty())\n            ttrect = this.draw_g.append(\"svg:circle\")\n                                .attr(\"class\",\"tooltip_bin\")\n                                .style(\"pointer-events\",\"none\")\n                                .attr(\"r\", radius)\n                                .call(this.lineatt.func)\n                                .call(this.fillatt.func);\n\n         res.exact = (Math.abs(midx - pnt.x) <= radius) && (Math.abs(midy - pnt.y) <= radius);\n\n         res.menu = res.exact; // show menu only when mouse pointer exactly over the histogram\n         res.menu_dist = Math.sqrt((midx-pnt.x)**2 + (midy-pnt.y)**2);\n\n         res.changed = ttrect.property(\"current_bin\") !== findbin;\n\n         if (res.changed)\n            ttrect.attr(\"cx\", midx)\n                  .attr(\"cy\", midy)\n                  .property(\"current_bin\", findbin);\n      }\n\n      if (res.changed)\n         res.user_info = { obj: histo,  name: \"histo\",\n                           bin: findbin, cont: histo.getBinContent(findbin+1),\n                           grx: midx, gry: midy };\n\n      return res;\n   }\n\n   /** @summary Fill histogram context menu */\n   fillHistContextMenu(menu) {\n\n      menu.add(\"Auto zoom-in\", () => this.autoZoom());\n\n      let opts = this.getSupportedDrawOptions();\n\n      menu.addDrawMenu(\"Draw with\", opts, arg => {\n         if (arg==='inspect')\n            return this.showInspector();\n\n         this.decodeOptions(arg); // obsolete, should be implemented differently\n\n         if (this.options.need_fillcol && this.fillatt && this.fillatt.empty())\n            this.fillatt.change(5,1001);\n\n         // redraw all objects\n         this.interactiveRedraw(\"pad\", \"drawopt\");\n      });\n   }\n\n   /** @summary Perform automatic zoom inside non-zero region of histogram */\n   autoZoom() {\n      let left = this.getSelectIndex(\"x\", \"left\", -1),\n          right = this.getSelectIndex(\"x\", \"right\", 1),\n          dist = right - left, histo = this.getHisto(), xaxis = this.getAxis(\"x\");\n\n      if (dist == 0) return;\n\n      // first find minimum\n      let min = histo.getBinContent(left + 1);\n      for (let indx = left; indx < right; ++indx)\n         min = Math.min(min, histo.getBinContent(indx+1));\n      if (min > 0) return; // if all points positive, no chance for autoscale\n\n      while ((left < right) && (histo.getBinContent(left+1) <= min)) ++left;\n      while ((left < right) && (histo.getBinContent(right) <= min)) --right;\n\n      // if singular bin\n      if ((left === right-1) && (left > 2) && (right < this.nbinsx-2)) {\n         --left; ++right;\n      }\n\n      if ((right - left < dist) && (left < right))\n         return this.getFramePainter().zoom(xaxis.GetBinCoord(left), xaxis.GetBinCoord(right));\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      let xaxis = this.getAxis(\"x\");\n\n      if ((axis == \"x\") && (xaxis.FindBin(max,0.5) - xaxis.FindBin(min,0) > 1)) return true;\n\n      if ((axis == \"y\") && (Math.abs(max-min) > Math.abs(this.ymax-this.ymin)*1e-6)) return true;\n\n      return false;\n   }\n\n   /** @summary Call appropriate draw function */\n   callDrawFunc(reason) {\n      let main = this.getFramePainter();\n\n      if (main && (main.mode3d !== this.options.Mode3D) && !this.isMainPainter())\n         this.options.Mode3D = main.mode3d;\n\n      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);\n   }\n\n   /** @summary Draw in 2d */\n   draw2D(reason) {\n      this.clear3DScene();\n\n      return this.drawFrameAxes().then(res => {\n         return res ? this.drawingBins(reason) : false;\n      }).then(res => {\n         if (res)\n            return this.draw1DBins().then(() => this.addInteractivity());\n      }).then(() => this);\n   }\n\n   /** @summary Draw in 3d */\n   draw3D(reason) {\n      console.log('3D drawing is disabled, load ./hist/RH1Painter.mjs');\n      return this.draw2D(reason);\n   }\n\n   /** @summary Readraw histogram */\n   redraw(reason) {\n      return this.callDrawFunc(reason);\n   }\n\n   static _draw(painter, opt) {\n      return ensureRCanvas(painter).then(() => {\n\n         painter.setAsMainPainter();\n\n         painter.options = { Hist: false, Bar: false, BarStyle: 0,\n                             Error: false, ErrorKind: -1, errorX: gStyle.fErrorX,\n                             Zero: false, Mark: false,\n                             Line: false, Fill: false, Lego: 0, Surf: 0,\n                             Text: false, TextAngle: 0, TextKind: \"\", AutoColor: 0,\n                             BarOffset: 0., BarWidth: 1., BaseLine: false, Mode3D: false };\n\n         let d = new DrawOptions(opt);\n         if (d.check('R3D_', true))\n            painter.options.Render3D = constants.Render3D.fromString(d.part.toLowerCase());\n\n         let kind = painter.v7EvalAttr(\"kind\", \"hist\"),\n             sub = painter.v7EvalAttr(\"sub\", 0),\n             has_main = !!painter.getMainPainter(),\n             o = painter.options;\n\n         o.Text = painter.v7EvalAttr(\"drawtext\", false);\n         o.BarOffset = painter.v7EvalAttr(\"baroffset\", 0.);\n         o.BarWidth = painter.v7EvalAttr(\"barwidth\", 1.);\n         o.second_x = has_main && painter.v7EvalAttr(\"secondx\", false);\n         o.second_y = has_main && painter.v7EvalAttr(\"secondy\", false);\n\n         switch(kind) {\n            case \"bar\": o.Bar = true; o.BarStyle = sub; break;\n            case \"err\": o.Error = true; o.ErrorKind = sub; break;\n            case \"p\": o.Mark = true; break;\n            case \"l\": o.Line = true; break;\n            case \"lego\": o.Lego = sub > 0 ? 10+sub : 12; o.Mode3D = true; break;\n            default: o.Hist = true;\n         }\n\n         painter.scanContent();\n\n         return painter.callDrawFunc();\n      });\n   }\n\n   /** @summary draw RH1 object */\n   static draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n","import { settings, gStyle } from '../core.mjs';\nimport { RH1Painter as RH1Painter2D } from '../hist2d/RH1Painter.mjs';\nimport { RAxisPainter } from '../gpad/RAxisPainter.mjs';\nimport { assignFrame3DMethods, drawBinsLego } from './hist3d.mjs';\n\nclass RH1Painter extends RH1Painter2D {\n\n   /** @summary Draw 1-D histogram in 3D mode */\n   draw3D(reason) {\n\n      this.mode3d = true;\n\n      let main = this.getFramePainter(), // who makes axis drawing\n          is_main = this.isMainPainter(), // is main histogram\n          zmult = 1 + 2*gStyle.fHistTopMargin,\n          pr = Promise.resolve(this);\n\n      if (reason == \"resize\")  {\n         if (is_main && main.resize3D()) main.render3D();\n         return pr;\n      }\n\n      this.deleteAttr();\n\n      this.scanContent(true); // may be required for axis drawings\n\n      if (is_main) {\n         assignFrame3DMethods(main);\n         pr = main.create3DScene(this.options.Render3D).then(() => {\n            main.setAxesRanges(this.getAxis(\"x\"), this.xmin, this.xmax, null, this.ymin, this.ymax, null, 0, 0);\n            main.set3DOptions(this.options);\n            main.drawXYZ(main.toplevel, RAxisPainter, { use_y_for_z: true, zmult, zoom: settings.Zooming, ndim: 1, draw: true, v7: true });\n         });\n      }\n\n      if (!main.mode3d)\n         return pr;\n\n      return pr.then(() => this.drawingBins(reason)).then(() => {\n\n         // called when bins received from server, must be reentrant\n         let main = this.getFramePainter();\n\n         drawBinsLego(this, true);\n         this.updatePaletteDraw();\n         main.render3D();\n         main.addKeysHandler();\n         return this;\n      });\n   }\n\n      /** @summary draw RH1 object */\n   static draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n\n"]}