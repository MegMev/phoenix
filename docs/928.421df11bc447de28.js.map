{"version":3,"file":"928.421df11bc447de28.js","mappings":"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","names":["RObjectPainter","drawContent","Promise","resolve","this","drawPave","rect","getPadPainter","getPadRect","fp","getFramePainter","onFrame","v7EvalAttr","corner","visible","offsetx","v7EvalLength","width","offsety","height","pave_width","pave_height","createG","draw_g","classed","createv7AttLine","createv7AttFill","pave_x","pave_y","fr","getFrameRect","x","y","kTopRight","attr","append","call","lineatt","func","fillatt","then","isBatchMode","settings","paveContextMenu","on","evnt","addDragHandler","minwidth","minheight","redraw","d","sizeChanged","drag","changes","v7AttrChange","v7SendAttrChanges","select","dom","pave","opt","painter","RPavePainter","ensureRCanvas","legend","getObject","textFont","v7EvalFont","size","color","align","nlines","fEntries","length","pp","fTitle","stepy","posy","margin_x","setSize","startTextDrawing","drawText","latex","text","i","objp","entry","w4","Math","round","fLabel","o","fDrawableId","findSnap","fDrawable","fIO","getDom","fLine","fFill","fMarker","createv7AttMarker","fError","markeratt","create","finishTextDrawing","RLegendPainter","pavetext","fText","undefined","RPaveTextPainter","clearStat","stats_lines","addText","line","push","updateStatistic","reply","lines","drawStatistic","fillStatistic","_fast_drawing","obj","fLines","v7OfflineMode","main","getMainPainter","gStyle","format","value","fmt","abs","toFixed","lastformat","res","floatToString","changeMask","nbit","mask","fShowMask","statsContextMenu","preventDefault","stopPropagation","createMenu","menu","action","bind","add","n","addchk","fillObjectExecMenu","show","first_stat","num_cols","maxlen","j","max","indexOf","parts","split","has_head","text_g","empty","selectAll","remove","max_hlen","slice","args","_expected_width","_args","post_process","ready","scaleTextDrawing","result_width","__expected_width","lpath","nrow","ncol","reason","v7NormalMode","req","_typename","v7SubmitRequest","stats","RHistStatsPainter"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/RPavePainter.mjs"],"sourcesContent":["import { settings, isBatchMode, gStyle } from '../core.mjs';\nimport { floatToString } from '../base/BasePainter.mjs';\nimport { RObjectPainter } from '../base/RObjectPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\nimport { addDragHandler } from '../gpad/TFramePainter.mjs';\n\n\nconst ECorner = { kTopLeft: 1, kTopRight: 2, kBottomLeft: 3, kBottomRight: 4 };\n\n/**\n * @summary Painter for RPave class\n *\n * @private\n */\n\nclass RPavePainter extends RObjectPainter {\n\n   /** @summary Draw pave content\n     * @desc assigned depending on pave class */\n   drawContent() { return Promise.resolve(this); }\n\n   /** @summary Draw pave */\n   drawPave() {\n\n      let rect = this.getPadPainter().getPadRect(),\n          fp = this.getFramePainter();\n\n      this.onFrame = fp && this.v7EvalAttr(\"onFrame\", true);\n      this.corner = this.v7EvalAttr(\"corner\", ECorner.kTopRight);\n\n      let visible      = this.v7EvalAttr(\"visible\", true),\n          offsetx      = this.v7EvalLength(\"offsetX\", rect.width, 0.02),\n          offsety      = this.v7EvalLength(\"offsetY\", rect.height, 0.02),\n          pave_width   = this.v7EvalLength(\"width\", rect.width, 0.3),\n          pave_height  = this.v7EvalLength(\"height\", rect.height, 0.3);\n\n      this.createG();\n\n      this.draw_g.classed(\"most_upper_primitives\", true); // this primitive will remain on top of list\n\n      if (!visible)\n         return Promise.resolve(this);\n\n      this.createv7AttLine(\"border_\");\n\n      this.createv7AttFill();\n\n      let pave_x = 0, pave_y = 0,\n          fr = this.onFrame ? fp.getFrameRect() : rect;\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + offsety;\n            break;\n         case ECorner.kBottomLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kBottomRight:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + offsety;\n      }\n\n      this.draw_g.attr(\"transform\", `translate(${pave_x},${pave_y})`);\n\n      this.draw_g.append(\"svg:rect\")\n                 .attr(\"x\", 0)\n                 .attr(\"width\", pave_width)\n                 .attr(\"y\", 0)\n                 .attr(\"height\", pave_height)\n                 .call(this.lineatt.func)\n                 .call(this.fillatt.func);\n\n      this.pave_width = pave_width;\n      this.pave_height = pave_height;\n\n      // here should be fill and draw of text\n\n      return this.drawContent().then(() => {\n\n         if (isBatchMode()) return this;\n\n         // TODO: provide pave context menu as in v6\n         if (settings.ContextMenu && this.paveContextMenu)\n            this.draw_g.on(\"contextmenu\", evnt => this.paveContextMenu(evnt));\n\n         addDragHandler(this, { x: pave_x, y: pave_y, width: pave_width, height: pave_height,\n                                minwidth: 20, minheight: 20, redraw: d => this.sizeChanged(d) });\n\n         return this;\n      });\n   }\n\n   /** @summary Process interactive moving of the stats box */\n   sizeChanged(drag) {\n      this.pave_width = drag.width;\n      this.pave_height = drag.height;\n\n      let pave_x = drag.x,\n          pave_y = drag.y,\n          rect = this.getPadPainter().getPadRect(),\n          fr = this.onFrame ? this.getFramePainter().getFrameRect() : rect,\n          offsetx = 0, offsety = 0, changes = {};\n\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            offsetx = pave_x - fr.x;\n            offsety = pave_y - fr.y;\n            break;\n         case ECorner.kBottomLeft:\n            offsetx = pave_x - fr.x;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kBottomRight:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = pave_y - fr.y;\n      }\n\n      this.v7AttrChange(changes, \"offsetX\", offsetx / rect.width);\n      this.v7AttrChange(changes, \"offsetY\", offsety / rect.height);\n      this.v7AttrChange(changes, \"width\", this.pave_width / rect.width);\n      this.v7AttrChange(changes, \"height\", this.pave_height / rect.height);\n      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server\n\n      this.draw_g.select(\"rect\")\n                 .attr(\"width\", this.pave_width)\n                 .attr(\"height\", this.pave_height);\n\n      this.drawContent();\n   }\n\n   /** @summary Redraw RPave object */\n   redraw(/*reason*/) {\n      return this.drawPave();\n   }\n\n   /** @summary draw RPave object */\n   static draw(dom, pave, opt) {\n      let painter = new RPavePainter(dom, pave, opt, \"pave\");\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n}\n\n\n/**\n * @summary Painter for RLegend class\n *\n * @private\n */\n\nclass RLegendPainter extends RPavePainter {\n\n   /** @summary draw RLegend content */\n   drawContent() {\n      let legend     = this.getObject(),\n          textFont   = this.v7EvalFont(\"text\", { size: 12, color: \"black\", align: 22 }),\n          width      = this.pave_width,\n          height     = this.pave_height,\n          nlines     = legend.fEntries.length,\n          pp         = this.getPadPainter();\n\n      if (legend.fTitle) nlines++;\n\n      if (!nlines || !pp) return Promise.resolve(this);\n\n      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2));\n      this.startTextDrawing(textFont, 'font' );\n\n      if (legend.fTitle) {\n         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: legend.fTitle });\n         posy += stepy;\n      }\n\n      for (let i = 0; i < legend.fEntries.length; ++i) {\n         let objp = null, entry = legend.fEntries[i], w4 = Math.round(width/4);\n\n         this.drawText({ latex: 1, width: 0.75*width - 3*margin_x, height: stepy, x: 2*margin_x + w4, y: posy, text: entry.fLabel });\n\n         if (entry.fDrawableId != \"custom\") {\n            objp = pp.findSnap(entry.fDrawableId, true);\n         } else if (entry.fDrawable.fIO) {\n            objp = new RObjectPainter(this.getDom(), entry.fDrawable.fIO);\n            if (entry.fLine) objp.createv7AttLine();\n            if (entry.fFill) objp.createv7AttFill();\n            if (entry.fMarker) objp.createv7AttMarker();\n         }\n\n         if (objp && entry.fFill && objp.fillatt)\n            this.draw_g\n              .append(\"svg:path\")\n              .attr(\"d\", `M${Math.round(margin_x)},${Math.round(posy + stepy*0.1)}h${w4}v${Math.round(stepy*0.8)}h${-w4}z`)\n              .call(objp.fillatt.func);\n\n         if (objp && entry.fLine && objp.lineatt)\n            this.draw_g\n              .append(\"svg:path\")\n              .attr(\"d\", `M${Math.round(margin_x)},${Math.round(posy + stepy/2)}h${w4}`)\n              .call(objp.lineatt.func);\n\n         if (objp && entry.fError && objp.lineatt)\n            this.draw_g\n              .append(\"svg:path\")\n              .attr(\"d\", `M${Math.round(margin_x + width/8)},${Math.round(posy + stepy*0.2)}v${Math.round(stepy*0.6)}`)\n              .call(objp.lineatt.func);\n\n         if (objp && entry.fMarker && objp.markeratt)\n            this.draw_g.append(\"svg:path\")\n                .attr(\"d\", objp.markeratt.create(margin_x + width/8, posy + stepy/2))\n                .call(objp.markeratt.func);\n\n         posy += stepy;\n      }\n\n      return this.finishTextDrawing();\n   }\n\n   /** @summary draw RLegend object */\n   static draw(dom, legend, opt) {\n      let painter = new RLegendPainter(dom, legend, opt, \"legend\");\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RLegendPainter\n\n\n/**\n * @summary Painter for RPaveText class\n *\n * @private\n */\n\nclass RPaveTextPainter extends RPavePainter {\n\n   /** @summary draw RPaveText content */\n   drawContent() {\n      let pavetext  = this.getObject(),\n          textFont  = this.v7EvalFont(\"text\", { size: 12, color: \"black\", align: 22 }),\n          width     = this.pave_width,\n          height    = this.pave_height,\n          nlines    = pavetext.fText.length;\n\n      if (!nlines) return;\n\n      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2))\n\n      this.startTextDrawing(textFont, 'font');\n\n      for (let i = 0; i < pavetext.fText.length; ++i) {\n         let line = pavetext.fText[i];\n\n         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: line });\n         posy += stepy;\n      }\n\n      return this.finishTextDrawing(undefined, true);\n   }\n\n   /** @summary draw RPaveText object */\n   static draw(dom, pave, opt) {\n      let painter = new RPaveTextPainter(dom, pave, opt, \"pavetext\");\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RPaveTextPainter\n\n/**\n * @summary Painter for RHistStats class\n *\n * @private\n */\n\nclass RHistStatsPainter extends RPavePainter {\n\n   /** @summary clear entries from stat box */\n   clearStat() {\n      this.stats_lines = [];\n   }\n\n   /** @summary add text entry to stat box */\n   addText(line) {\n      this.stats_lines.push(line);\n   }\n\n   /** @summary update statistic from the server */\n   updateStatistic(reply) {\n      this.stats_lines = reply.lines;\n      this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary fill statistic */\n   fillStatistic() {\n      let pp = this.getPadPainter();\n      if (pp?._fast_drawing) return false;\n\n      let obj = this.getObject();\n      if (obj.fLines !== undefined) {\n         this.stats_lines = obj.fLines;\n         delete obj.fLines;\n         return true;\n      }\n\n      if (this.v7OfflineMode()) {\n         let main = this.getMainPainter();\n         if (typeof main?.fillStatistic !== 'function') return false;\n         // we take statistic from main painter\n         return main.fillStatistic(this, gStyle.fOptStat, gStyle.fOptFit);\n      }\n\n      // show lines which are exists, maybe server request will be recieved later\n      return (this.stats_lines !== undefined);\n   }\n\n   /** @summary format float value as string\n     * @private */\n   format(value, fmt) {\n      if (!fmt) fmt = \"stat\";\n\n      switch(fmt) {\n         case \"stat\" : fmt = gStyle.fStatFormat; break;\n         case \"fit\": fmt = gStyle.fFitFormat; break;\n         case \"entries\": if ((Math.abs(value) < 1e9) && (Math.round(value) == value)) return value.toFixed(0); fmt = \"14.7g\"; break;\n         case \"last\": fmt = this.lastformat; break;\n      }\n\n      let res = floatToString(value, fmt || \"6.4g\", true);\n\n      this.lastformat = res[1];\n\n      return res[0];\n   }\n\n   /** @summary Draw content */\n   drawContent() {\n      if (this.fillStatistic())\n         return this.drawStatistic(this.stats_lines);\n\n      return Promise.resolve(this);\n   }\n\n   /** @summary Change mask */\n   changeMask(nbit) {\n      let obj = this.getObject(), mask = (1<<nbit);\n      if (obj.fShowMask & mask)\n         obj.fShowMask = obj.fShowMask & ~mask;\n      else\n         obj.fShowMask = obj.fShowMask | mask;\n\n      if (this.fillStatistic())\n         this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary Context menu */\n   statsContextMenu(evnt) {\n      evnt.preventDefault();\n      evnt.stopPropagation(); // disable main context menu\n\n      createMenu(evnt, this).then(menu => {\n         let obj = this.getObject(),\n             action = this.changeMask.bind(this);\n\n         menu.add(\"header: StatBox\");\n\n         for (let n=0;n<obj.fEntries.length; ++n)\n            menu.addchk((obj.fShowMask & (1<<n)), obj.fEntries[n], n, action);\n\n         return this.fillObjectExecMenu(menu);\n     }).then(menu => menu.show());\n   }\n\n   /** @summary Draw statistic */\n   drawStatistic(lines) {\n\n      let textFont = this.v7EvalFont(\"stats_text\", { size: 12, color: \"black\", align: 22 }),\n          first_stat = 0, num_cols = 0, maxlen = 0,\n          width = this.pave_width,\n          height = this.pave_height;\n\n      if (!lines) return Promise.resolve(this);\n\n      let nlines = lines.length;\n      // adjust font size\n      for (let j = 0; j < nlines; ++j) {\n         let line = lines[j];\n         if (j > 0) maxlen = Math.max(maxlen, line.length);\n         if ((j == 0) || (line.indexOf('|') < 0)) continue;\n         if (first_stat === 0) first_stat = j;\n         let parts = line.split(\"|\");\n         if (parts.length > num_cols)\n            num_cols = parts.length;\n      }\n\n      // for characters like 'p' or 'y' several more pixels required to stay in the box when drawn in last line\n      let stepy = height / nlines, has_head = false, margin_x = 0.02 * width;\n\n      let text_g = this.draw_g.select(\".statlines\");\n      if (text_g.empty())\n         text_g = this.draw_g.append(\"svg:g\").attr(\"class\", \"statlines\");\n      else\n         text_g.selectAll(\"*\").remove();\n\n      textFont.setSize(height/(nlines * 1.2));\n      this.startTextDrawing(textFont, 'font' , text_g);\n\n      if (nlines == 1) {\n         this.drawText({ width: width, height: height, text: lines[0], latex: 1, draw_g: text_g });\n      } else\n      for (let j = 0; j < nlines; ++j) {\n         let posy = j*stepy;\n\n         if (first_stat && (j >= first_stat)) {\n            let parts = lines[j].split(\"|\");\n            for (let n = 0; n < parts.length; ++n)\n               this.drawText({ align: \"middle\", x: width * n / num_cols, y: posy, latex: 0,\n                               width: width/num_cols, height: stepy, text: parts[n], draw_g: text_g });\n         } else if (lines[j].indexOf('=') < 0) {\n            if (j == 0) {\n               has_head = true;\n               let max_hlen = Math.max(maxlen, Math.round((width-2*margin_x)/stepy/0.65));\n               if (lines[j].length > max_hlen + 5)\n                  lines[j] = lines[j].slice(0,max_hlen+2) + \"...\";\n            }\n            this.drawText({ align: (j == 0) ? \"middle\" : \"start\", x: margin_x, y: posy,\n                            width: width - 2*margin_x, height: stepy, text: lines[j], draw_g: text_g });\n         } else {\n            let parts = lines[j].split(\"=\"), args = [];\n\n            for (let n = 0; n < 2; ++n) {\n               let arg = {\n                  align: (n == 0) ? \"start\" : \"end\", x: margin_x, y: posy,\n                  width: width-2*margin_x, height: stepy, text: parts[n], draw_g: text_g,\n                  _expected_width: width-2*margin_x, _args: args,\n                  post_process(painter) {\n                    if (this._args[0].ready && this._args[1].ready)\n                       painter.scaleTextDrawing(1.05*(this._args[0].result_width && this._args[1].result_width)/this.__expected_width, this.draw_g);\n                  }\n               };\n               args.push(arg);\n            }\n\n            for (let n = 0; n < 2; ++n)\n               this.drawText(args[n]);\n         }\n      }\n\n      let lpath = \"\";\n\n      if (has_head)\n         lpath += \"M0,\" + Math.round(stepy) + \"h\" + width;\n\n      if ((first_stat > 0) && (num_cols > 1)) {\n         for (let nrow = first_stat; nrow < nlines; ++nrow)\n            lpath += \"M0,\" + Math.round(nrow * stepy) + \"h\" + width;\n         for (let ncol = 0; ncol < num_cols - 1; ++ncol)\n            lpath += \"M\" + Math.round(width / num_cols * (ncol + 1)) + \",\" + Math.round(first_stat * stepy) + \"V\" + height;\n      }\n\n      if (lpath) this.draw_g.append(\"svg:path\").attr(\"d\",lpath) /*.call(this.lineatt.func)*/;\n\n      return this.finishTextDrawing(text_g);\n   }\n\n   /** @summary Redraw stats box */\n   redraw(reason) {\n      if (reason && (typeof reason == \"string\") && (reason.indexOf(\"zoom\") == 0) && this.v7NormalMode()) {\n         let req = {\n            _typename: \"ROOT::Experimental::RHistStatBoxBase::RRequest\",\n            mask: this.getObject().fShowMask // lines to show in stat box\n         };\n\n         this.v7SubmitRequest(\"stat\", req, reply => this.updateStatistic(reply));\n      }\n\n      return this.drawPave();\n   }\n\n   /** @summary draw RHistStats object */\n   static draw(dom, stats, opt) {\n      let painter = new RHistStatsPainter(dom, stats, opt, stats);\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RHistStatsPainter\n\n\nexport { RPavePainter, RLegendPainter, RPaveTextPainter, RHistStatsPainter };\n"]}