{"version":3,"file":"897.b6b64c0933ea6f8a.js","mappings":"wMAYA,gBAAiCA,KAK9BC,YAAYC,EAAKC,GACdC,MAAMF,EAAKC,GACXE,KAAKC,aAAe,KACpBD,KAAKE,WAAY,EACjBF,KAAKG,SAAW,GAInBC,UACGJ,KAAKG,SAAW,GAChBJ,MAAMK,UAITC,aAAaC,WACV,IAAKN,KAAKO,gBAAgBD,GAAM,OAAO,EAEvC,IAAIR,EAASE,KAAKQ,YACdC,EAASH,EAAII,QACbC,EAAKX,KAAKY,gBAEdd,EAAOe,OAASP,EAAIO,OAEpB,IAAIC,GAAQ,EACZ,GAAId,KAAKC,aAAc,CACpB,IAAIc,EAAQT,EAAIU,WACZhB,KAAKE,YAAca,IACpBA,EAAQf,KAAKiB,gBAAgBR,IAE5BT,KAAKC,aAAaI,aAAaU,KAAQD,GAAQ,GAGtD,QAASI,EAAI,EAAGA,EAAIT,EAAOU,IAAIC,SAAUF,EACjCA,EAAIlB,KAAKG,SAASiB,QAAWpB,KAAKG,SAASe,GAAGb,aAAaI,EAAOU,IAAID,MACxEJ,GAAQ,GAEdR,2BAAIe,iBAAJf,IAAgBa,MAAhBb,EAAqBgB,QAAQC,WACtBA,iBAAMC,aAAaD,iBAAME,SAC1Bd,0BAAIe,eAAe,KAAMH,EAAKE,MAAOF,EAAKC,aAA1Cb,EAAsDN,aAAakB,MAGlET,EAKVG,gBAAgBR,EAAQM,EAAOY,GAC5B,IACIC,EAASC,EAASC,EAAIC,EADtBjC,EAASE,KAAKQ,YACYwB,EAAQ,EAAGC,EAAQ,EAAGC,GAAO,EAAOC,GAAO,EACrEC,GAAe,EAAOC,EAAc,GACpCC,EAAK,CAAGC,KAAM,EAAGC,KAAM,EAAGC,KAAM,EAAGC,KAAM,EAAGC,OAAO,GAcvD,GAZIhB,IACDO,EAAOP,EAAIiB,MACXT,EAAOR,EAAIkB,MACXP,EAAGC,KAAOZ,EAAImB,OACdR,EAAGE,KAAOb,EAAIoB,OACdT,EAAGG,KAAOd,EAAIqB,OACdV,EAAGI,KAAOf,EAAIsB,OACdX,EAAGK,OAAQ,GAGV3C,KAAKkD,KAAOnC,IAAUA,EAAMoC,OAAOC,UAASrC,EAAQ,MAEpDA,GAGD,GAFAc,EAAUd,EAAMsC,OAAOC,MACvB1B,EAAUb,EAAMsC,OAAOE,MACnB5B,EAAK,CACN,MAAM6B,EAASC,GAAM9B,EAAIiB,OAAUa,EAAI,GAAOC,KAAKC,IAAI,eAAiBF,GAAKA,EAC7EzB,EAAQwB,EAAOlB,EAAGC,MAClBN,EAAQuB,EAAOlB,EAAGE,YAGrBxC,KAAKE,WAAY,EAEjBO,EAAOU,IAAIG,QAAQsC,IAChB,GAAmB,GAAfA,EAAGC,SACP,CAAIvB,EAAGK,QACJL,EAAGC,KAAOD,EAAGE,KAAOoB,EAAGE,GAAG,GAC1BxB,EAAGG,KAAOH,EAAGI,KAAOkB,EAAGG,GAAG,GAC1BzB,EAAGK,OAAQ,GAEd,QAASzB,EAAI,EAAGA,EAAI0C,EAAGC,WAAY3C,EAChCoB,EAAGC,KAAOmB,KAAKM,IAAI1B,EAAGC,KAAMqB,EAAGE,GAAG5C,IAClCoB,EAAGE,KAAOkB,KAAKO,IAAI3B,EAAGE,KAAMoB,EAAGE,GAAG5C,IAClCoB,EAAGG,KAAOiB,KAAKM,IAAI1B,EAAGG,KAAMmB,EAAGG,GAAG7C,IAClCoB,EAAGI,KAAOgB,KAAKO,IAAI3B,EAAGI,KAAMkB,EAAGG,GAAG7C,OAIpCT,EAAOU,IAAI,IAAMV,EAAOU,IAAI,GAAGH,YAAcP,EAAOU,IAAI,GAAGH,WAAWmC,OAAOe,eAC9E9B,GAAe,EACfC,EAAc5B,EAAOU,IAAI,GAAGH,WAAWmC,OAAOgB,aAG7C7B,EAAGC,MAAQD,EAAGE,OAAMF,EAAGE,MAAQ,GAC/BF,EAAGG,MAAQH,EAAGI,OAAMJ,EAAGI,MAAQ,GACnCZ,EAAK,KAAQQ,EAAGE,KAAOF,EAAGC,MAC1BR,EAAK,KAAQO,EAAGI,KAAOJ,EAAGG,MAC1BT,EAAQM,EAAGC,KAAOT,EAClBG,EAAQK,EAAGE,KAAOV,EAClBsC,GACO9B,EAAGG,MAAQ,IAAGH,EAAGG,KAAO,KAAQH,EAAGI,MACvCb,EAAUS,EAAGG,MAAQ,EAAI,GAAMiB,KAAKW,MAAM/B,EAAGI,KAAOJ,EAAGG,OACvDb,EAAUU,EAAGI,MAAQ,EAAI,GAAMgB,KAAKW,MAAM/B,EAAGI,KAAOJ,EAAGG,SAEvDZ,EAAUS,EAAGG,KAAOV,EACpBH,EAAUU,EAAGI,KAAOX,GAEnBF,EAAU,GAAKS,EAAGG,MAAQ,IAC3BZ,EAAU,GACTD,EAAU,GAAKU,EAAGI,MAAQ,IAC3Bd,EAAU,GAqBhB,GAlBII,EAAQ,GAAKM,EAAGC,MAAQ,IACzBP,EAAQE,EAAO,GAAMI,EAAGC,KAAO,GAC9BN,EAAQ,GAAKK,EAAGE,MAAQ,IACzBP,EAAQC,EAAM,IAAMI,EAAGE,KAAO,IAEV,MAAnB1C,EAAOwE,WACRhC,EAAGG,KAAOZ,EAAU/B,EAAOwE,WACP,MAAnBxE,EAAOyE,WACRjC,EAAGI,KAAOd,EAAU9B,EAAOyE,UAE1B1C,EAAU,GAAKS,EAAGG,MAAQ,GAAKN,IAAMN,EAAU,GAAMS,EAAGG,MACxDb,EAAU,GAAKU,EAAGI,MAAQ,GAAKP,IAAMP,EAAU,IAAMU,EAAGI,MACxDb,GAAW,GAAKM,IAAMN,EAAU,KAAQD,IACvCO,GAAQN,EAAU,GAAKA,EAAU,IAAKD,IAASC,EAAU,GAC1DG,GAAS,GAAKE,IACfF,EAASC,EAAQ,IAAQ,EAAI,KAAQA,IAGnClB,EAAO,CACT,IAAIyD,EAAOC,EACX,GAAIzE,KAAKkD,IAAK,CAEXsB,GADAzD,GAAQ2D,YAAO,SACDvB,OACdqB,EAAMlB,MAAQ,EACdkB,EAAMjB,MAAQ9C,EAAOU,IAAIC,OACzBoD,EAAMG,OAASlE,EAAOU,IAAIC,OAC1BoD,EAAMpB,SAAUsB,YAAO,aACvB,QAASxD,EAAI,EAAGA,EAAIT,EAAOU,IAAIC,OAAQF,IAAK,CACzC,IAAI0D,GAAMF,YAAO,cACjBE,EAAIC,QAAUpE,EAAOU,IAAID,GAAGL,QAAW,KAAIK,IAC3C0D,EAAIE,UAAYrE,EAAOU,IAAIC,OAASF,EACpCsD,EAAMpB,QAAQ2B,IAAIH,EAAK,IAE1BJ,EAAQzD,EAAMsC,OACdoB,EAAQ1D,EAAMiE,YAGdR,GADAzD,GAAQ2D,YAAO,SACDvB,OACdsB,EAAQ1D,EAAMsC,OAGjB,GADAtC,EAAMF,OAASf,EAAOe,OAClBE,EAAMF,OAAOoE,QAAQ,MAAQ,EAAG,CACjC,IAAIC,EAAInE,EAAMF,OAAOsE,MAAM,KAC3BpE,EAAMF,OAASqE,EAAE,GACbA,EAAE,KAAIV,EAAM3D,OAASqE,EAAE,IACvBA,EAAE,KAAIT,EAAM5D,OAASqE,EAAE,IAG9BV,EAAMlB,MAAQtB,EACdwC,EAAMjB,MAAQtB,EACduC,EAAMN,aAAe9B,EACjBA,IAAcoC,EAAML,YAAc9B,GAGzC,OAAIrC,KAAKkD,KACNnC,EAAMuD,SAAWzC,EACjBd,EAAMwD,SAAW3C,IAEjBb,EAAMsC,OAAOC,MAAQzB,EACrBd,EAAMsC,OAAOE,MAAQ3B,GAGjBb,EAKVqE,aAAarE,EAAOsE,GACjB,OAAOC,SAAgBtF,KAAKuF,SAAUxE,EAAO,OAASsE,GAIzDG,iBAAiBC,GAEd,IAAI3F,EAASE,KAAKQ,YAElB,OAAKV,EAAOuB,YAAeoE,GAAQ3F,EAAOuB,WAAWF,IAAIC,OAC/CsE,QAAQC,QAAQ3F,MAInBW,KAFOC,gBAEJgF,WAAW5F,KAAKuF,SAAUzF,EAAOuB,WAAWF,IAAIsE,GAAO3F,EAAOuB,WAAWwE,IAAIJ,IAC7EK,KAAK,IAAM9F,KAAKwF,iBAAiBC,EAAK,IAGnDM,UAAUnC,EAAIiC,GACX,OAAOG,qBAAmBhG,KAAKuF,SAAU3B,EAAIiC,GAIhDI,cAAcR,EAAMI,GAEjB,IAAIpF,EAAST,KAAKQ,YAAYE,QAG9B,GAAI+E,GAAQhF,EAAOU,IAAIC,OACpB,YAAK8E,KAAOlG,KAAKmG,KAAOnG,KAAKoG,MAAO,EAC7BpG,KAAKwF,iBAAiB,GAIhC,GAAIxF,KAAKkG,MAAQlG,KAAKmG,MAAQnG,KAAKoG,KAAM,CACtC,IAAIC,EAAKrG,KAAKsG,iBACd,GAAkC,mBAAvBD,iBAAIE,iBAA+B,CAC3C,IAAIC,EAASH,EAAGE,gBAAgB9F,EAAOU,IAAIC,QACvCpB,KAAKkG,OAAMzF,EAAOU,IAAIsE,GAAMgB,WAAaD,GACzCxG,KAAKmG,OAAM1F,EAAOU,IAAIsE,GAAMiB,WAAaF,GACzCxG,KAAKoG,OAAM3F,EAAOU,IAAIsE,GAAMkB,aAAeH,IAMrD,OAAOxG,KAAK+F,UAAUtF,EAAOU,IAAIsE,GAFzBhF,EAAOoF,IAAIJ,IAASI,GAAO,GAEQpF,EAAOU,IAAIC,OAASqE,GAAMK,KAAKc,IACnEA,GAAM5G,KAAKG,SAAS0G,KAAKD,GAEtB5G,KAAKiG,cAAcR,EAAK,EAAGI,oBAKzBiB,EAASjB,GAErB,IAAIkB,EAAI,IAAIC,KAAYnB,GAExBiB,EAAQ5D,IAAM6D,EAAEE,MAAM,MACtBH,EAAQZ,KAAOa,EAAEE,MAAM,OACvBH,EAAQX,KAAOY,EAAEE,MAAM,OACvBH,EAAQV,KAAOW,EAAEE,MAAM,OAEvB,IAAI5B,EAAO,GAAgB,CAAC,gBAAiB,QAAS,OAAQ,OAAQ,OAAQ,SAAU,QAAS,QAAS,SAAU,QAAS,QAAS,MAC5H/D,QAAQ4F,IAAcH,EAAEE,MAAMC,KAAO7B,GAAQ,IAAM6B,KAE7D,IAAIC,EAAUzB,QAAQC,SAAQ,GAC9B,GAAIoB,EAAEE,MAAM,OAASH,EAAQR,iBAAkB,CAC3C,IAAIxG,EAASgH,EAAQtG,YACjBG,EAAKmG,EAAQlG,gBACbG,EAAQ+F,EAAQ7F,gBAAgBnB,EAAOY,QAASZ,EAAOkB,WAAYL,iBAAIyG,YAAW,IAEvFD,EAAUL,EAAQ1B,aAAarE,EAAOsE,GAAMS,KAAKuB,IAC9CP,EAAQ7G,aAAeoH,EACvBA,EAAGC,YAAa,IAItB,OAAOH,EAAQrB,KAAK,KACjBgB,EAAQS,qBACDT,EAAQb,cAAc,EAAGc,EAAES,wBAK5B3H,EAAKC,EAAQ+F,GACtB,OAAO4B,EAAmBC,QAAQ,IAAID,EAAmB5H,EAAKC,GAAS+F,4BCvR7E,gBAAiC8B,EAI9BvC,aAAarE,EAAOsE,GACjB,OAAOrF,KAAKkD,IAAM0E,kBAAgB5H,KAAKuF,SAAUxE,EAAO,SAAWsE,GACjDC,SAAgBtF,KAAKuF,SAAUxE,EAAO,OAASsE,GAGpEU,UAAUnC,EAAIiC,EAAKgC,GAChB,OAAI7H,KAAKkD,MAAK2C,GAAO,SAASgC,GACvB7B,SAAmBhG,KAAKuF,SAAU3B,EAAIiC,eAIpChG,EAAKC,EAAQ+F,GACtB,OAAO4B,EAAmBC,QAAQ,IAAID,EAAmB5H,EAAKC,GAAS+F","names":["ObjectPainter","constructor","dom","mgraph","super","this","firstpainter","autorange","painters","cleanup","updateObject","obj","matchObjectType","getObject","graphs","fGraphs","pp","getPadPainter","fTitle","isany","histo","fHistogram","scanGraphsRange","i","arr","length","fFunctions","forEach","func","_typename","fName","findPainterFor","pad","maximum","minimum","dx","dy","uxmin","uxmax","logx","logy","time_display","time_format","rw","xmin","xmax","ymin","ymax","first","fLogx","fLogy","fUxmin","fUxmax","fUymin","fUymax","_3d","fXaxis","fLabels","fYaxis","fXmin","fXmax","padtoX","x","Math","exp","gr","fNpoints","fX","fY","min","max","fTimeDisplay","fTimeFormat","u","log10","fMinimum","fMaximum","xaxis","yaxis","create","fNbins","lbl","fString","fUniqueID","Add","fZaxis","indexOf","t","split","drawAxisHist","hopt","TH1Painter","getDom","drawNextFunction","indx","Promise","resolve","drawObject","opt","then","drawGraph","TGraphPainter","drawNextGraph","_pfc","_plc","_pmc","mp","getMainPainter","createAutoColor","icolor","fFillColor","fLineColor","fMarkerColor","subp","push","painter","d","DrawOptions","check","name","promise","getRootPad","fp","$secondary","addToPadPrimitives","remain","TMultiGraphPainter","_drawMG","TMultiGraphPainter2D","TH2Painter","pos3d"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist2d/TMultiGraphPainter.mjs","../node_modules/jsroot/modules/hist/TMultiGraphPainter.mjs"],"sourcesContent":["import { create } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { TGraphPainter } from './TGraphPainter.mjs';\n\n/**\n * @summary Painter for TMultiGraph object.\n *\n * @private\n */\n\nclass TMultiGraphPainter extends ObjectPainter {\n\n   /** @summary Create painter\n     * @param {object|string} dom - DOM element for drawing or element id\n     * @param {object} obj - TMultiGraph object to draw */\n   constructor(dom, mgraph) {\n      super(dom, mgraph);\n      this.firstpainter = null;\n      this.autorange = false;\n      this.painters = []; // keep painters to be able update objects\n   }\n\n   /** @summary Cleanup multigraph painter */\n   cleanup() {\n      this.painters = [];\n      super.cleanup();\n   }\n\n   /** @summary Update multigraph object */\n   updateObject(obj) {\n      if (!this.matchObjectType(obj)) return false;\n\n      let mgraph = this.getObject(),\n          graphs = obj.fGraphs,\n          pp = this.getPadPainter();\n\n      mgraph.fTitle = obj.fTitle;\n\n      let isany = false;\n      if (this.firstpainter) {\n         let histo = obj.fHistogram;\n         if (this.autorange && !histo)\n            histo = this.scanGraphsRange(graphs);\n\n         if (this.firstpainter.updateObject(histo)) isany = true;\n      }\n\n      for (let i = 0; i < graphs.arr.length; ++i)\n         if ((i < this.painters.length) && this.painters[i].updateObject(graphs.arr[i]))\n            isany = true;\n\n      obj.fFunctions?.arr?.forEach(func => {\n         if (func?._typename && func?.fName)\n            pp?.findPainterFor(null, func.fName, func._typename)?.updateObject(func);\n      });\n\n      return isany;\n   }\n\n   /** @summary Scan graphs range\n     * @returns {object} histogram for axes drawing */\n   scanGraphsRange(graphs, histo, pad) {\n      let mgraph = this.getObject(),\n          maximum, minimum, dx, dy, uxmin = 0, uxmax = 0, logx = false, logy = false,\n          time_display = false, time_format = \"\",\n          rw = {  xmin: 0, xmax: 0, ymin: 0, ymax: 0, first: true };\n\n      if (pad) {\n         logx = pad.fLogx;\n         logy = pad.fLogy;\n         rw.xmin = pad.fUxmin;\n         rw.xmax = pad.fUxmax;\n         rw.ymin = pad.fUymin;\n         rw.ymax = pad.fUymax;\n         rw.first = false;\n      }\n\n      if (this._3d && histo && !histo.fXaxis.fLabels) histo = null;\n\n      if (histo) {\n         minimum = histo.fYaxis.fXmin;\n         maximum = histo.fYaxis.fXmax;\n         if (pad) {\n            const padtoX = x => (pad.fLogx && (x < 50)) ? Math.exp(2.302585092994 * x) : x;\n            uxmin = padtoX(rw.xmin);\n            uxmax = padtoX(rw.xmax);\n         }\n      } else {\n         this.autorange = true;\n\n         graphs.arr.forEach(gr => {\n            if (gr.fNpoints == 0) return;\n            if (rw.first) {\n               rw.xmin = rw.xmax = gr.fX[0];\n               rw.ymin = rw.ymax = gr.fY[0];\n               rw.first = false;\n            }\n            for (let i = 0; i < gr.fNpoints; ++i) {\n               rw.xmin = Math.min(rw.xmin, gr.fX[i]);\n               rw.xmax = Math.max(rw.xmax, gr.fX[i]);\n               rw.ymin = Math.min(rw.ymin, gr.fY[i]);\n               rw.ymax = Math.max(rw.ymax, gr.fY[i]);\n            }\n         });\n\n         if (graphs.arr[0] && graphs.arr[0].fHistogram && graphs.arr[0].fHistogram.fXaxis.fTimeDisplay) {\n            time_display = true;\n            time_format = graphs.arr[0].fHistogram.fXaxis.fTimeFormat;\n         }\n\n         if (rw.xmin == rw.xmax) rw.xmax += 1.;\n         if (rw.ymin == rw.ymax) rw.ymax += 1.;\n         dx = 0.05 * (rw.xmax - rw.xmin);\n         dy = 0.05 * (rw.ymax - rw.ymin);\n         uxmin = rw.xmin - dx;\n         uxmax = rw.xmax + dx;\n         if (logy) {\n            if (rw.ymin <= 0) rw.ymin = 0.001 * rw.ymax;\n            minimum = rw.ymin / (1 + 0.5 * Math.log10(rw.ymax / rw.ymin));\n            maximum = rw.ymax * (1 + 0.2 * Math.log10(rw.ymax / rw.ymin));\n         } else {\n            minimum = rw.ymin - dy;\n            maximum = rw.ymax + dy;\n         }\n         if (minimum < 0 && rw.ymin >= 0)\n            minimum = 0;\n         if (maximum > 0 && rw.ymax <= 0)\n            maximum = 0;\n      }\n\n      if (uxmin < 0 && rw.xmin >= 0)\n         uxmin = logx ? 0.9 * rw.xmin : 0;\n      if (uxmax > 0 && rw.xmax <= 0)\n         uxmax = logx? 1.1 * rw.xmax : 0;\n\n      if (mgraph.fMinimum != -1111)\n         rw.ymin = minimum = mgraph.fMinimum;\n      if (mgraph.fMaximum != -1111)\n         rw.ymax = maximum = mgraph.fMaximum;\n\n      if (minimum < 0 && rw.ymin >= 0 && logy) minimum = 0.9 * rw.ymin;\n      if (maximum > 0 && rw.ymax <= 0 && logy) maximum = 1.1 * rw.ymax;\n      if (minimum <= 0 && logy) minimum = 0.001 * maximum;\n      if (!logy && minimum > 0 && minimum < 0.05*maximum) minimum = 0;\n      if (uxmin <= 0 && logx)\n         uxmin = (uxmax > 1000) ? 1 : 0.001 * uxmax;\n\n      // Create a temporary histogram to draw the axis (if necessary)\n      if (!histo) {\n         let xaxis, yaxis;\n         if (this._3d) {\n            histo = create(\"TH2I\");\n            xaxis = histo.fXaxis;\n            xaxis.fXmin = 0;\n            xaxis.fXmax = graphs.arr.length;\n            xaxis.fNbins = graphs.arr.length;\n            xaxis.fLabels = create(\"THashList\");\n            for (let i = 0; i < graphs.arr.length; i++) {\n               let lbl = create(\"TObjString\");\n               lbl.fString = graphs.arr[i].fTitle || `gr${i}`;\n               lbl.fUniqueID = graphs.arr.length - i; // graphs drawn in reverse order\n               xaxis.fLabels.Add(lbl, \"\");\n            }\n            xaxis = histo.fYaxis;\n            yaxis = histo.fZaxis;\n         } else {\n            histo = create(\"TH1I\");\n            xaxis = histo.fXaxis;\n            yaxis = histo.fYaxis;\n         }\n         histo.fTitle = mgraph.fTitle;\n         if (histo.fTitle.indexOf(\";\") >= 0) {\n            let t = histo.fTitle.split(\";\");\n            histo.fTitle = t[0];\n            if (t[1]) xaxis.fTitle = t[1];\n            if (t[2]) yaxis.fTitle = t[2];\n         }\n\n         xaxis.fXmin = uxmin;\n         xaxis.fXmax = uxmax;\n         xaxis.fTimeDisplay = time_display;\n         if (time_display) xaxis.fTimeFormat = time_format;\n      }\n\n      if (this._3d) {\n         histo.fMinimum = minimum;\n         histo.fMaximum = maximum;\n      } else {\n         histo.fYaxis.fXmin = minimum;\n         histo.fYaxis.fXmax = maximum;\n      }\n\n      return histo;\n   }\n\n   /** @summary draw speical histogram for axis\n     * @returns {Promise} when ready */\n   drawAxisHist(histo, hopt) {\n      return TH1Painter.draw(this.getDom(), histo, \"AXIS\" + hopt);\n   }\n\n   /** @summary method draws next function from the functions list  */\n   drawNextFunction(indx) {\n\n      let mgraph = this.getObject();\n\n      if (!mgraph.fFunctions || (indx >= mgraph.fFunctions.arr.length))\n         return Promise.resolve(this);\n\n      let pp = this.getPadPainter()\n\n      return pp.drawObject(this.getDom(), mgraph.fFunctions.arr[indx], mgraph.fFunctions.opt[indx])\n               .then(() => this.drawNextFunction(indx+1));\n   }\n\n   drawGraph(gr, opt /*, pos3d */ ) {\n      return TGraphPainter.draw(this.getDom(), gr, opt);\n   }\n\n   /** @summary method draws next graph  */\n   drawNextGraph(indx, opt) {\n\n      let graphs = this.getObject().fGraphs;\n\n      // at the end of graphs drawing draw functions (if any)\n      if (indx >= graphs.arr.length) {\n         this._pfc = this._plc = this._pmc = false; // disable auto coloring at the end\n         return this.drawNextFunction(0);\n      }\n\n      // if there is auto colors assignment, try to provide it\n      if (this._pfc || this._plc || this._pmc) {\n         let mp = this.getMainPainter();\n         if (typeof mp?.createAutoColor == 'function') {\n            let icolor = mp.createAutoColor(graphs.arr.length);\n            if (this._pfc) graphs.arr[indx].fFillColor = icolor;\n            if (this._plc) graphs.arr[indx].fLineColor = icolor;\n            if (this._pmc) graphs.arr[indx].fMarkerColor = icolor;\n         }\n      }\n\n      let o = graphs.opt[indx] || opt || \"\";\n\n      return this.drawGraph(graphs.arr[indx], o, graphs.arr.length - indx).then(subp => {\n         if (subp) this.painters.push(subp);\n\n         return this.drawNextGraph(indx+1, opt);\n      });\n   }\n\n   /** @private */\n   static _drawMG(painter, opt) {\n\n      let d = new DrawOptions(opt);\n\n      painter._3d = d.check(\"3D\");\n      painter._pfc = d.check(\"PFC\");\n      painter._plc = d.check(\"PLC\");\n      painter._pmc = d.check(\"PMC\");\n\n      let hopt = \"\", checkhopt = [\"USE_PAD_TITLE\", \"LOGXY\", \"LOGX\", \"LOGY\", \"LOGZ\", \"GRIDXY\", \"GRIDX\", \"GRIDY\", \"TICKXY\", \"TICKX\", \"TICKY\", \"FB\"];\n      checkhopt.forEach(name => { if (d.check(name)) hopt += \";\" + name; });\n\n      let promise = Promise.resolve(true);\n      if (d.check(\"A\") || !painter.getMainPainter()) {\n          let mgraph = painter.getObject(),\n              pp = painter.getPadPainter(),\n              histo = painter.scanGraphsRange(mgraph.fGraphs, mgraph.fHistogram, pp?.getRootPad(true));\n\n         promise = painter.drawAxisHist(histo, hopt).then(fp => {\n            painter.firstpainter = fp;\n            fp.$secondary = true; // mark histogram painter as secondary\n         });\n      }\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         return painter.drawNextGraph(0, d.remain());\n      });\n   }\n\n   /** @summary Draw TMultiGraph object */\n   static draw(dom, mgraph, opt) {\n      return TMultiGraphPainter._drawMG(new TMultiGraphPainter(dom, mgraph), opt);\n   }\n\n\n} // class TMultiGraphPainter\n\n\nexport { TMultiGraphPainter };\n","import { TMultiGraphPainter as TMultiGraphPainter2D } from '../hist2d/TMultiGraphPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport { TH2Painter } from './TH2Painter.mjs';\nimport { TGraphPainter } from './TGraphPainter.mjs';\n\n\nclass TMultiGraphPainter extends TMultiGraphPainter2D {\n\n   /** @summary draw speical histogram for axis\n     * @returns {Promise} when ready */\n   drawAxisHist(histo, hopt) {\n      return this._3d ? TH2Painter.draw(this.getDom(), histo, \"AXIS3D\" + hopt)\n                      : TH1Painter.draw(this.getDom(), histo, \"AXIS\" + hopt);\n   }\n\n   drawGraph(gr, opt, pos3d) {\n      if (this._3d) opt += \"pos3d_\"+pos3d;\n      return TGraphPainter.draw(this.getDom(), gr, opt);\n   }\n\n   /** @summary Draw TMultiGraph object */\n   static draw(dom, mgraph, opt) {\n      return TMultiGraphPainter._drawMG(new TMultiGraphPainter(dom, mgraph), opt);\n   }\n\n} // class TMultiGraphPainter\n\nexport { TMultiGraphPainter };\n"]}